extensions:
    - citus

objects:
- role:
    name: postgres
    super: true

- role:
    name: minerva
    super: false
    inherit: true
    createrole: false
    createdb: false
    login: false

- role:
    name: minerva_writer
    super: false
    inherit: true
    createrole: false
    createdb: false
    login: false
    memberships:
    - minerva

- role:
    name: minerva_admin
    super: false
    inherit: true
    createrole: false
    createdb: false
    login: true
    memberships:
    - minerva
    - minerva_writer
    - postgres

- schema:
    name: public

- schema:
    name: system

- schema:
    name: directory
    comment: Stores contextual information for the data. This includes the entities,
      entity_types, data_sources, etc. It is the entrypoint when looking for data.
    privileges:
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "directory"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "directory" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: entity
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,INSERT,UPDATE,DELETE
    - role: minerva
      objclass: tables
      privilege: SELECT
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "entity"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "entity" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "entity" GRANT SELECT ON tables TO "minerva"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "entity" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: alias
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva
      objclass: tables
      privilege: SELECT
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,UPDATE,DELETE
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "alias"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "alias" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "alias" GRANT SELECT ON tables TO "minerva"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "alias" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)      

- schema:
    name: alias_def
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva
      objclass: tables
      privilege: SELECT
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,UPDATE,DELETE
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "alias_def"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "alias_def" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "alias_def" GRANT SELECT ON tables TO "minerva"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "alias_def" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)      

- schema:
    name: alias_directory
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "alias_directory"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "alias_directory" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: relation
    comment: >
      Stores the actual relations between entities in tables.
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,INSERT,UPDATE,DELETE
    - role: minerva
      objclass: tables
      privilege: SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "relation"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "relation" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "relation" GRANT SELECT ON tables TO "minerva"; $$)

- schema:
    name: relation_def
    comment: >
      Stores the views that define the contents of the relation tables.
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva
      objclass: tables
      privilege: SELECT
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,INSERT,UPDATE,DELETE
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "relation_def"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "relation_def" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "relation_def" GRANT SELECT ON tables TO "minerva"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "relation_def" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: relation_directory
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "relation_directory"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "relation_directory" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: trend
    comment: Stores information with fixed interval and format, like periodic measurements.
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,INSERT,UPDATE,DELETE
    - role: minerva
      objclass: tables
      privilege: SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "trend"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trend" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trend" GRANT SELECT ON tables TO "minerva"; $$)

- schema:
    name: trend_partition
    comment: Holds partitions of the trend store tables in the trend schema.
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,INSERT,UPDATE,DELETE
    - role: minerva
      objclass: tables
      privilege: SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "trend_partition"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trend_partition" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trend_partition" GRANT SELECT ON tables TO "minerva"; $$)

- schema:
    name: trend_directory
    privileges:
    - role: minerva_writer
      privilege: USAGE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT

- schema:
    name: attribute
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: ALL
    - role: minerva
      objclass: tables
      privilege: SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "attribute"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_base" GRANT ALL ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_base" GRANT SELECT ON tables TO "minerva"; $$)

- schema:
    name: attribute_base
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: ALL
    - role: minerva
      objclass: tables
      privilege: SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "attribute_base"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_base" GRANT ALL ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_base" GRANT SELECT ON tables TO "minerva"; $$)

- schema:
    name: attribute_directory
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "attribute_directory"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_directory" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: attribute_history
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: ALL
    - role: minerva
      objclass: tables
      privilege: SELECT
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "attribute_history"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_history" GRANT ALL ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_history" GRANT SELECT ON tables TO "minerva"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_history" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: attribute_staging
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,INSERT,UPDATE,DELETE
    - role: minerva
      objclass: tables
      privilege: SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "attribute_staging"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_staging" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "attribute_staging" GRANT SELECT ON tables TO "minerva"; $$)

- schema:
    name: notification
    comment: |-
      Stores information of events that can occur at irregular intervals,
      but still have a fixed, known format. This schema is dynamically populated.
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: tables
      privilege: ALL
    - role: minerva
      objclass: tables
      privilege: SELECT
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "notification"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "notification" GRANT ALL ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "notification" GRANT SELECT ON tables TO "minerva"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "notification" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: notification_directory
    comment: Stores meta-data about notification data in the notification schema.
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "notification_directory"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "notification_directory" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: metric
    privileges:
    - role: minerva
      privilege: USAGE

- schema:
    name: virtual_entity
    privileges:
    - role: minerva
      privilege: USAGE

- schema:
    name: olap
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE

- schema:
    name: trigger
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "trigger"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trigger" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)

- schema:
    name: trigger_rule
    privileges:
    - role: minerva_writer
      privilege: USAGE,CREATE
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva
      objclass: tables
      privilege: SELECT
    - role: minerva_admin
      objclass: tables
      privilege: ALL
    - role: minerva_writer
      objclass: tables
      privilege: SELECT,INSERT,UPDATE,DELETE
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT
    - role: minerva
      objclass: functions
      privilege: EXECUTE
    postqueries:
    - query: run_command_on_workers($$ CREATE SCHEMA "trigger_rule"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trigger_rule" GRANT SELECT ON tables TO "minerva"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trigger_rule" GRANT ALL ON tables TO "minerva_admin"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trigger_rule" GRANT SELECT,INSERT,UPDATE,DELETE ON tables TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trigger_rule" GRANT USAGE,SELECT ON sequences TO "minerva_writer"; $$)
    - query: run_command_on_workers($$ ALTER DEFAULT PRIVILEGES IN SCHEMA "trigger_rule" GRANT EXECUTE ON functions TO "minerva"; $$)

- schema:
    name: logging
    privileges:
    - role: minerva
      privilege: USAGE
    default-privileges:
    - role: minerva_writer
      objclass: sequences
      privilege: USAGE,SELECT

- function:
    name: integer_to_array
    schema: public
    return_type: integer[]
    language: plpgsql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - name: value
      data_type: integer
    source: |-
      BEGIN
          RETURN ARRAY[value];
      END;

- function:
    name: smallint_to_array
    schema: public
    return_type: smallint[]
    language: plpgsql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - name: value
      data_type: smallint
    source: |-
      BEGIN
          RETURN ARRAY[value];
      END;

- function:
    name: smallint_to_timestamp_without_time_zone
    schema: public
    return_type: timestamp without time zone
    language: plpgsql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: smallint
    source: |-
      BEGIN
          RETURN NULL;
      END;

- function:
    name: smallint_to_timestamp_with_time_zone
    schema: public
    return_type: timestamp with time zone
    language: plpgsql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: smallint
    source: |-
      BEGIN
          RETURN NULL;
      END;

- function:
    name: column_names
    schema: public
    return_type: name
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: namespace
      data_type: name
    - name: table
      data_type: name
    source: |-
      SELECT a.attname
      FROM pg_catalog.pg_class c
      JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
      JOIN pg_catalog.pg_attribute a ON a.attrelid = c.oid
      WHERE
          n.nspname = $1 AND
          c.relname = $2 AND
          a.attisdropped = false AND
          a.attnum > 0;

- function:
    name: fst
    schema: public
    return_type: anyelement
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - data_type: anyelement
    - data_type: anyelement
    source: |-
      SELECT $1;

- function:
    name: snd
    schema: public
    return_type: anyelement
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - data_type: anyelement
    - data_type: anyelement
    source: |-
      SELECT $2;

- function:
    name: safe_division
    schema: public
    return_type: anyelement
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - name: numerator
      data_type: anyelement
    - name: denominator
      data_type: anyelement
    source: |-
      SELECT CASE
          WHEN $2 = 0 THEN
              NULL
          ELSE
              $1 / $2
          END;

- function:
    name: safe_division
    schema: public
    return_type: anyelement
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - name: numerator
      data_type: anyelement
    - name: denominator
      data_type: anyelement
    - name: division_by_zero_indicator 
      data_type: anyelement
    source: |-
      SELECT CASE
          WHEN $2 = 0 THEN
              $3
          ELSE
              $1 / $2
          END;

- function:
    name: add_array
    schema: public
    return_type: anyarray
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: anyarray
    - data_type: anyarray
    source: |-
      SELECT array_agg((arr1 + arr2)) FROM
      (
          SELECT
              unnest($1[1:least(array_length($1,1), array_length($2,1))]) AS arr1,
              unnest($2[1:least(array_length($1,1), array_length($2,1))]) AS arr2
      ) AS foo;

- aggregate:
    name: sum_array
    schema: public
    sfunc: add_array
    stype: anyarray
    arguments:
    - data_type: anyarray

- function:
    name: divide_array
    schema: public
    return_type: anyarray
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: anyarray
    - data_type: anyelement
    source: |-
      SELECT array_agg(arr / $2) FROM
      (
          SELECT unnest($1) AS arr
      ) AS foo;

- function:
    name: divide_array
    schema: public
    return_type: anyarray
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: anyarray
    - data_type: anyarray
    source: |-
      SELECT array_agg(public.safe_division(arr1, arr2)) FROM
      (
          SELECT
          unnest($1[1:least(array_length($1,1), array_length($2,1))]) AS arr1,
          unnest($2[1:least(array_length($1,1), array_length($2,1))]) AS arr2
      ) AS foo;

- function:
    name: array_sum
    schema: public
    return_type: anyelement
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - data_type: anyarray
    source: |-
      SELECT sum(t) FROM unnest($1) t;

- function:
    name: array_to_text
    schema: public
    return_type: text
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - data_type: anyarray
    postqueries:
    - query: create_distributed_function('array_to_text(anyarray)')
    source: |-
      SELECT array_to_string($1, ',')

- function:
    name: to_pdf
    schema: public
    return_type: integer[]
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      SELECT array_agg(nullif(x, '')::int)
      FROM unnest(string_to_array($1, ',')) AS x;

- function:
    name: action
    schema: public
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: sql
      data_type: text
    postqueries:
    - query: create_distributed_function('action(text)')
    source: |-
      BEGIN
          EXECUTE sql;
      END;

- function:
    name: action_count
    schema: public
    return_type: integer
    language: plpgsql
    volatility: volatile
    arguments:
    - name: sql
      data_type: text
    postqueries:
    - query: create_distributed_function('action_count(text)')
    source: |-
      DECLARE
          row_count integer;
      BEGIN
          EXECUTE sql;

          GET DIAGNOSTICS row_count = ROW_COUNT;

          RETURN row_count;
      END;

- function:
    name: action
    schema: public
    return_type: anyelement
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: anyelement
    - name: sql
      data_type: text
    postqueries:
    - query: create_distributed_function('action(anyelement,text)')
    source: |-
      BEGIN
          EXECUTE sql;

          RETURN $1;
      END;

- function:
    name: action
    schema: public
    return_type: anyelement
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: anyelement
    - name: sql
      data_type: text[]
    postqueries:
    - query: create_distributed_function('action(anyelement,text[])')
    source: |-
      DECLARE
          statement text;
      BEGIN
          FOREACH statement IN ARRAY sql LOOP
              EXECUTE statement;
          END LOOP;

          RETURN $1;
      END;

- function:
    name: table_exists
    schema: public
    return_type: bool
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: schema_name
      data_type: name
    - name: table_name
      data_type: name
    source: |-
      SELECT exists(
          SELECT 1
          FROM pg_class
          JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
          WHERE relname = $2 AND relkind = 'r' AND pg_namespace.nspname = $1
      );

- function:
    name: raise_exception
    schema: public
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: message
      data_type: anyelement
    source: |-
      BEGIN
          RAISE EXCEPTION '%', message;
      END;

- function:
    name: raise_info
    schema: public
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: message
      data_type: anyelement
    source: |-
      BEGIN
          RAISE INFO '%', message;
      END;

- function:
    name: switch_off_citus
    schema: public
    return_type: void
    language: sql
    volatility: volatile
    source: |-
      CREATE OR REPLACE FUNCTION create_distributed_table(text, text) RETURNS VOID AS $$ SELECT 42; $$ LANGUAGE sql STABLE;
      CREATE OR REPLACE FUNCTION create_reference_table(text) RETURNS VOID AS $$ SELECT 42; $$ LANGUAGE sql STABLE;
      CREATE OR REPLACE FUNCTION create_distributed_function(text) RETURNS VOID AS $$ SELECT 42; $$ LANGUAGE sql STABLE;

- aggregate:
    name: first
    schema: public
    sfunc: fst
    stype: anyelement
    postqueries:
    - query: create_distributed_function('first(anyelement)')
    arguments:
    - data_type: anyelement

- aggregate:
    name: last
    schema: public
    sfunc: snd
    stype: anyelement
    postqueries:
    - query: create_distributed_function('last(anyelement)')
    arguments:
    - data_type: anyelement

- table:
    name: setting
    schema: system
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: text
      nullable: false
    - name: value
      data_type: text
      nullable: true
    primary_key:
      name: setting_pkey
      columns:
      - id
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- composite_type:
    name: version_tuple
    schema: system
    columns:
    - name: major
      data_type: smallint
      nullable: false
    - name: minor
      data_type: smallint
      nullable: false
    - name: patch
      data_type: smallint
      nullable: false

- function:
    name: version
    schema: system
    return_type: system.version_tuple
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT (6,0,0)::system.version_tuple;

- function:
    name: get_setting
    schema: system
    return_type: system.setting
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - name: name
      data_type: text
    source: |-
      SELECT setting FROM system.setting WHERE name = $1;

- function:
    name: add_setting
    schema: system
    return_type: system.setting
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - name: name
      data_type: text
    - name: value
      data_type: text
    source: |-
      INSERT INTO system.setting (name, value) VALUES ($1, $2) RETURNING setting;

- function:
    name: update_setting
    schema: system
    return_type: system.setting
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - name: name
      data_type: text
    - name: value
      data_type: text
    source: |-
      UPDATE system.setting SET value = $2 WHERE name = $1 RETURNING setting;

- function:
    name: set_setting
    schema: system
    return_type: system.setting
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - name: name
      data_type: text
    - name: value
      data_type: text
    source: |-
      SELECT COALESCE(system.update_setting($1, $2), system.add_setting($1, $2));

- function:
    name: get_setting_value
    schema: system
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - name: name
      data_type: text
    source: |-
      SELECT value FROM system.setting WHERE name = $1;

- function:
    name: get_setting_value
    schema: system
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - name: name
      data_type: text
    - name: default
      data_type: text
    source: |-
      SELECT COALESCE(system.get_setting_value($1), $2);

- table:
    name: data_source
    schema: directory
    description: |-
      Describes data_sources. A data_source is used to indicate where data came
      from. Datasources are also used to prevent collisions between sets of
      data from different sources, where names can be the same, but the meaning
      of the data differs.
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: varchar
      nullable: false
    - name: description
      data_type: varchar
      nullable: false
    primary_key:
      name: data_source_pkey
      columns:
      - id
    indexes:
    - name: ix_directory_data_source_name
      unique: true
      definition: btree (name)
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: entity_type
    schema: directory
    description: |-
      Stores the entity types that exist in the entity table. Entity types are
      also used to give context to data that is stored for entities.
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: varchar
      nullable: false
    - name: description
      data_type: varchar
      nullable: false
    primary_key:
      name: entity_type_pkey
      columns:
      - id
    indexes:
    - name: ix_directory_entity_type_name
      unique: true
      definition: btree (lower((name)::text))
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: tag_group
    schema: directory
    description: |-
      Stores groups that can be related to by tags.
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: varchar
      nullable: false
    - name: complementary
      data_type: bool
      nullable: false
    primary_key:
      name: tag_group_pkey
      columns:
      - id
    indexes:
    - name: ix_directory_tag_group_name
      unique: true
      definition: btree (lower((name)::text))
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: tag
    schema: directory
    description: |-
      Stores all tags. A tag is a simple label that can be attached to a number of object types in the database, such as entities and trends.
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: varchar
      nullable: false
    - name: tag_group_id
      data_type: integer
      nullable: false
    - name: description
      data_type: varchar
      nullable: true
    primary_key:
      name: tag_pkey
      columns:
      - id
    foreign_keys:
    - name: tag_tag_group_id_fkey
      columns:
      - tag_group_id
      references:
        table:
          name: tag_group
          schema: directory
        columns:
        - id
      on_delete: cascade
    indexes:
    - name: ix_directory_tag_name
      unique: true
      definition: btree (lower((name)::text))
    - name: tag_lower_id_idx
      unique: false
      definition: btree (lower((name)::text), id)
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: get_entity_type_name
    schema: directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: integer
    source: |-
      SELECT name FROM directory.entity_type WHERE id = $1;

- function:
    name: get_entity_type
    schema: directory
    return_type: directory.entity_type
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      SELECT entity_type FROM directory.entity_type WHERE lower(name) = lower($1);

- function:
    name: get_data_source
    schema: directory
    return_type: directory.data_source
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      SELECT * FROM directory.data_source WHERE name = $1;

- function:
    name: create_data_source
    schema: directory
    return_type: directory.data_source
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      INSERT INTO directory.data_source (name, description)
      VALUES ($1, 'default');
      SELECT * FROM directory.data_source WHERE name = $1;

- function:
    name: create_entity_table_sql
    schema: entity
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT ARRAY[
            format(
              'CREATE TABLE IF NOT EXISTS entity.%I('
              'id serial,'
              'name text UNIQUE,'
              'created timestamp with time zone default now()'
              ');',
              $1.name
            ),
            format(
               'SELECT create_reference_table(''entity.%I'');',
               $1.name
            )
        ];

- function:
    name: create_entity_table
    schema: entity
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT public.action($1, entity.create_entity_table_sql($1));

- function:
    name: to_entity_function_name
    schema: entity
    return_type: name
    language: sql
    volatility: stable
    arguments:
    - data_type: directory.entity_type
    source: |-
      SELECT format('to_%s', $1.name)::name;

- function:
    name: get_entity_function_name
    schema: entity
    return_type: name
    language: sql
    volatility: stable
    arguments:
    - data_type: directory.entity_type
    source: |-
      SELECT format('get_%s', $1.name)::name;

- function:
    name: create_entity_function_name
    schema: entity
    return_type: name
    language: sql
    volatility: stable
    arguments:
    - data_type: directory.entity_type
    source: |-
      SELECT format('create_%s', $1.name)::name;

- function:
    name: create_create_entity_function_sql
    schema: entity
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT ARRAY[
            format(
              'CREATE FUNCTION entity.%I(text) RETURNS entity.%I
              AS $$
                INSERT INTO entity.%I(name) VALUES ($1) ON CONFLICT DO NOTHING;
                SELECT e FROM entity.%I e WHERE name = $1;
              $$ LANGUAGE sql',
              entity.create_entity_function_name($1),
              $1.name,
              $1.name,
              $1.name,
              $1.name
            )
        ];

- function:
    name: create_create_entity_function
    schema: entity
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT public.action($1, entity.create_create_entity_function_sql($1));

- function:
    name: create_get_entity_function_sql
    schema: entity
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT ARRAY[
            format(
              'CREATE FUNCTION entity.%I(text) RETURNS entity.%I
              AS $$
                SELECT * FROM entity.%I WHERE name = $1;
              $$ LANGUAGE sql',
              entity.get_entity_function_name($1),
              $1.name,
              $1.name
            )
        ];

- function:
    name: create_get_entity_function
    schema: entity
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT public.action($1, entity.create_get_entity_function_sql($1));

- function:
    name: create_to_entity_function_sql
    schema: entity
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT ARRAY[
            format(
              'CREATE FUNCTION entity.%I(text) RETURNS entity.%I
              AS $$
                SELECT coalesce(entity.%I($1), entity.%I($1));
              $$ LANGUAGE sql',
              entity.to_entity_function_name($1),
              $1.name,
              entity.get_entity_function_name($1),
              entity.create_entity_function_name($1)
            )
        ];

- function:
    name: create_to_entity_function
    schema: entity
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
        SELECT public.action($1, entity.create_to_entity_function_sql($1));

- function:
    name: define_entity_type
    schema: directory
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      INSERT INTO directory.entity_type(name, description)
      VALUES ($1, '')
      ON CONFLICT DO NOTHING;
      SELECT * FROM directory.entity_type WHERE name = $1;

- function:
    name: init_entity_type
    schema: directory
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: directory.entity_type
    source: |-
      SELECT entity.create_entity_table($1);
      SELECT entity.create_get_entity_function($1);
      SELECT entity.create_create_entity_function($1);
      SELECT entity.create_to_entity_function($1);

- function:
    name: create_entity_type
    schema: directory
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      SELECT directory.init_entity_type(directory.define_entity_type($1));

- function:
    name: name_to_entity_type
    schema: directory
    return_type: directory.entity_type
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      SELECT COALESCE(directory.get_entity_type($1), directory.create_entity_type($1));

- function:
    name: name_to_data_source
    schema: directory
    return_type: directory.data_source
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      SELECT COALESCE(directory.get_data_source($1), directory.create_data_source($1));

- table:
    name: alias_type
    schema: alias_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: varchar
      nullable: false
    primary_key:
      name: alias_type_pkey
      columns:
      - id
    indexes:
    - name: alias_type_name_lower_idx
      unique: true
      definition: btree (name, lower((name)::text))

- function:
    name: alias_schema
    schema: alias_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT 'alias'::name;

- function:
    name: initialize_alias_type_sql
    schema: alias_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: alias_directory.alias_type
    source: |-
      SELECT ARRAY[
          format(
              'CREATE TABLE %I.%I ('
              '  entity_id serial PRIMARY KEY,'
              '  alias text NOT NULL,'
              ');',
              alias_directory.alias_schema(),
              $1.name, $1.name
          ),
          format(
              'CREATE INDEX ON %I.%I USING btree(alias);',
              alias_directory.alias_schema(),
              $1.name
          )
      ];

- function:
    name: initialize_alias_type
    schema: alias_directory
    return_type: alias_directory.alias_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: alias_directory.alias_type
    source: |-
      SELECT public.action($1, alias_directory.initialize_alias_type_sql($1));

- function:
    name: update_alias_sql
    schema: alias_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: alias_directory.alias_type
    source: |-
      SELECT ARRAY[
          format(
              'DELETE FROM %I.%I',
              alias_directory.alias_schema(),
              $1.name
          ),
          format(
              'INSERT INTO %I.%I(entity_id, alias) SELECT entity_id, alias FROM alias_def.%I'
              ');',
              alias_directory.alias_schema(),
              $1.name, $1.name
          )
      ];

- function:
    name: update_alias
    schema: alias_directory
    return_type: alias_directory.alias_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: alias_directory.alias_type
    source: |-
      SELECT public.action($1, alias_directory.update_alias_sql($1));

- function:
    name: drop_alias_type_sql
    schema: alias_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: alias_directory.alias_type
    source: |-
      SELECT format(
          'DROP TABLE %I.%I;',
          alias_directory.alias_schema(),
          $1.name
      );

- function:
    name: delete_alias_type
    schema: alias_directory
    return_type: alias_directory.alias_type
    language: sql
    volatility: volatile
    arguments:
    - data_type: alias_directory.alias_type
    source: |-
      DELETE FROM alias_directory.alias_type WHERE id = $1.id;
      SELECT public.action($1, alias_directory.drop_alias_type_sql($1));

- function:
    name: get_alias
    schema: alias_directory
    return_type: text
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: entity_id
      data_type: integer
    - name: alias_type_name
      data_type: text
    source: |-
      DECLARE
          result text;
      BEGIN
          EXECUTE format(
              'SELECT alias FROM alias.%I WHERE entity_id = %s',
              $2, $1
          ) INTO result;
          RETURN result;
      END;

- function:
    name: define_alias_type
    schema: alias_directory
    return_type: alias_directory.alias_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    source: |-
      INSERT INTO alias_directory.alias_type(name) VALUES ($1) RETURNING *;
    description: |-
      Define a new alias type, but do not create a table for it.

- function:
    name: get_alias_type
    schema: alias_directory
    return_type: alias_directory.alias_type
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    source: |-
      SELECT alias_type FROM alias_directory.alias_type WHERE name = $1;

- function:
    name: create_alias_type
    schema: alias_directory
    return_type: alias_directory.alias_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    source: |-
      SELECT alias_directory.initialize_alias_type(
          alias_directory.define_alias_type($1)
      );
    description: |-
      Define a new alias type and created the table for storing the aliases.

- function:
    name: get_or_create_alias_type
    schema: alias_directory
    return_type: alias_directory.alias_type
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    source: |-
      SELECT COALESCE(
        alias_directory.get_alias_type($1),
        alias_directory.create_alias_type($1)
      );

- enum_type:
    schema: relation_directory
    name: type_cardinality_enum
    labels:
    - one-to-one
    - one-to-many
    - many-to-one

- table:
    name: type
    schema: relation_directory
    columns:
    - name: id
      data_type: serial
    - name: name
      data_type: name
      nullable: false
    - name: cardinality
      data_type: relation_directory.type_cardinality_enum
      nullable: true
    primary_key:
      name: type_pkey
      columns:
      - id
    indexes:
    - name: type_name_key
      unique: true
      definition: btree (name)
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: table_schema
    schema: relation_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT 'relation'::name;

- function:
    name: get_type
    schema: relation_directory
    return_type: relation_directory.type
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: name
    source: |-
      SELECT type FROM relation_directory.type WHERE name = $1;

- function:
    name: register_type
    schema: relation_directory
    return_type: relation_directory.type
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: name
    source: |-
      INSERT INTO relation_directory.type (name) VALUES ($1) RETURNING type;

- function:
    name: name_to_type
    schema: relation_directory
    return_type: relation_directory.type
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: name
    source: |-
      SELECT COALESCE(
        relation_directory.get_type($1),
        relation_directory.register_type($1)
      );

- function:
    name: remove
    schema: relation_directory
    return_type: text
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    source: |-
      DECLARE
        result text;
      BEGIN
        SELECT name FROM relation_directory.type WHERE name = $1 INTO result;
        PERFORM public.action(format('DROP TABLE IF EXISTS relation.%I', $1));
        PERFORM public.action(format('DROP FUNCTION IF EXISTS relation_directory.%I', format('materialize_%s', $1)));
        DELETE FROM relation_directory.type WHERE name = $1;
        RETURN result;
      END;

- table:
    name: job
    schema: logging
    columns:
    - name: id
      data_type: bigserial
    - name: action
      data_type: jsonb
      nullable: false
    - name: started
      data_type: timestamp with time zone
      nullable: false
    - name: finished
      data_type: timestamp with time zone
      nullable: true
    primary_key:
      name: job_pkey
      columns:
      - id
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: start_job
    schema: logging
    return_type: bigint
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: action
      data_type: jsonb
    source: |-
      INSERT INTO logging.job(action, started) VALUES ($1, clock_timestamp())
      RETURNING job.id;

- function:
    name: end_job
    schema: logging
    return_type: void
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: job_id
      data_type: bigint
    source: |-
      UPDATE logging.job SET finished=clock_timestamp() WHERE id=$1;

- composite_type:
    name: fingerprint
    schema: trend_directory
    columns:
    - name: modified
      data_type: timestamp with time zone
      nullable: false
    - name: body
      data_type: jsonb
      nullable: false

- composite_type:
    name: trend_descr
    schema: trend_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false
    - name: description
      data_type: text
      nullable: false
    - name: time_aggregation
      data_type: text
      nullable: false
    - name: entity_aggregation
      data_type: text
      nullable: false
    - name: extra_data
      data_type: jsonb
      nullable: false

- composite_type:
    name: generated_trend_descr
    schema: trend_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false
    - name: description
      data_type: text
      nullable: false
    - name: expression
      data_type: text
      nullable: false
    - name: extra_data
      data_type: jsonb
      nullable: false

- composite_type:
    name: trend_view_part_descr
    schema: trend_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: query
      data_type: text
      nullable: false

- composite_type:
    name: trend_store_part_descr
    schema: trend_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: trends
      data_type: trend_directory.trend_descr[]
      nullable: false
    - name: generated_trends
      data_type: trend_directory.generated_trend_descr[]
      nullable: false

- table:
    name: trend_store
    schema: trend_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: entity_type_id
      data_type: integer
      nullable: true
    - name: data_source_id
      data_type: integer
      nullable: true
    - name: granularity
      data_type: interval
      nullable: false
    - name: partition_size
      data_type: interval
      nullable: false
    - name: retention_period
      data_type: interval
      nullable: false
      default: '''1 mon''::interval'
    primary_key:
      name: trend_store_pkey
      columns:
      - id
    description: |-
      Table based trend stores describing the common properties of all its
      partitions like entity type, data granularity, etc.
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE
    foreign_keys:
    - name: trend_store_entity_type_id_fkey
      columns:
      - entity_type_id
      references:
        table:
          name: entity_type
          schema: directory
        columns:
        - id
      on_delete: cascade
    - name: trend_store_data_source_id_fkey
      columns:
      - data_source_id
      references:
        table:
          name: data_source
          schema: directory
        columns:
        - id
    indexes:
    - name: trend_store_unique_constraint
      unique: true
      definition: btree (entity_type_id, data_source_id, granularity)

- table:
    name: trend_store_part
    schema: trend_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: name
      nullable: false
    - name: trend_store_id
      data_type: integer
      nullable: false
    primary_key:
      name: trend_store_part_pkey
      columns:
      - id
    foreign_keys:
    - name: trend_store_part_trend_store_id_fkey
      columns:
      - trend_store_id
      references:
        table:
          name: trend_store
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    description: |-
      The parts of a horizontally partitioned table trend store. Each table trend store has at least 1 part.
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: partition
    schema: trend_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: trend_store_part_id
      data_type: integer
      nullable: false
    - name: name
      data_type: name
      nullable: false
    - name: index
      data_type: integer
      nullable: false
    - name: from
      data_type: timestamp with time zone
      nullable: false
    - name: to
      data_type: timestamp with time zone
      nullable: false
    primary_key:
      name: partition_pkey
      columns:
      - id
    foreign_keys:
    - name: partition_trend_store_part_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    description: |-
      The parts of a vertically partitioned trend store part.
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: trend_view
    schema: trend_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: entity_type_id
      data_type: integer
      nullable: true
    - name: data_source_id
      data_type: integer
      nullable: true
    - name: granularity
      data_type: interval
      nullable: false
    primary_key:
      name: trend_view_pkey
      columns:
      - id
    description: |-
      View based trend stores describing the properties like entity type, data granularity, etc.
    foreign_keys:
    - name: trend_view_entity_type_id_fkey
      columns:
      - entity_type_id
      references:
        table:
          name: entity_type
          schema: directory
        columns:
        - id
      on_delete: cascade
    - name: trend_view_data_source_id_fkey
      columns:
      - data_source_id
      references:
        table:
          name: data_source
          schema: directory
        columns:
        - id
    indexes:
    - name: trend_view_unique_constraint
      unique: true
      definition: btree (entity_type_id, data_source_id, granularity)

- table:
    name: trend_view_part
    schema: trend_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: name
      nullable: false
    - name: trend_view_id
      data_type: integer
      nullable: false
    primary_key:
      name: trend_view_part_pkey
      columns:
      - id
    foreign_keys:
    - name: trend_view_part_trend_view_id_fkey
      columns:
      - trend_view_id
      references:
        table:
          name: trend_view
          schema: trend_directory
        columns:
        - id
      on_delete: cascade

- table:
    name: view_trend
    schema: trend_directory
    columns:
    - name: id
      data_type: integer
      generated_identity: by_default
      nullable: false
    - name: trend_view_part_id
      data_type: integer
      nullable: false
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false
    - name: extra_data
      data_type: jsonb
      nullable: false
      default: "'{}'"
    - name: description
      data_type: text
      nullable: false
    - name: time_aggregation
      data_type: text
      nullable: false
    - name: entity_aggregation
      data_type: text
      nullable: false
    primary_key:
      name: trend_pkey
      columns:
      - id
    foreign_keys:
    - name: table_trend_trend_view_part_id_fkey
      columns:
      - trend_view_part_id
      references:
        table:
          name: trend_view_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: table_trend
    schema: trend_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: trend_store_part_id
      data_type: integer
      nullable: false
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false
    - name: extra_data
      data_type: jsonb
      nullable: false
      default: "'{}'"
    - name: description
      data_type: text
      nullable: false
    - name: time_aggregation
      data_type: text
      nullable: false
    - name: entity_aggregation
      data_type: text
      nullable: false
    primary_key:
      name: trend_pkey
      columns:
      - id
    foreign_keys:
    - name: table_trend_trend_store_part_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: generated_table_trend
    schema: trend_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: trend_store_part_id
      data_type: integer
      nullable: false
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false
    - name: expression
      data_type: text
      nullable: false
    - name: extra_data
      data_type: jsonb
      nullable: false
      default: "'{}'"
    - name: description
      data_type: text
      nullable: false
    primary_key:
      name: generated_table_trend_pkey
      columns:
      - id
    foreign_keys:
    - name: table_trend_trend_store_part_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: table_trend_tag_link
    schema: trend_directory
    columns:
    - name: table_trend_id
      data_type: integer
      nullable: false
    - name: tag_id
      data_type: integer
      nullable: false
    primary_key:
      name: trend_tag_link_pkey
      columns:
      - table_trend_id
      - tag_id
    foreign_keys:
    - name: table_trend_tag_link_table_trend_id_fkey
      columns:
      - table_trend_id
      references:
        table:
          name: table_trend
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    - name: table_trend_tag_link_tag_id_fkey
      columns:
      - tag_id
      references:
        table:
          name: tag
          schema: directory
        columns:
        - id
      on_delete: cascade

- table:
    name: modified_log
    schema: trend_directory
    description: >
      The ``modified_log`` table stores records of when what ``trend_store_part``
      is modified and for what timestamp. This table is typically populated by
      data loading tools that call the ``trend_directory.mark_modified`` function.
      It is not populated automatically when inserting into the
      trend_store_part tables. The main purpose is to decouple the logging of
      data changes from actions triggered by those changes. There are no
      triggers on this table, and any actions should be triggered by changes on
      the ``trend_directory.modified`` table, which is updated by a separate
      processed based on the contents of this table.
    columns:
    - name: id
      data_type: bigserial
      nullable: false
      description: Unique identifier for the log entry
    - name: trend_store_part_id
      data_type: integer
      nullable: false
      description: Reference to the trend_store_part
    - name: timestamp
      data_type: timestamp with time zone
      nullable: false
      description: Timestamp of the data in the trend_store_part
    - name: modified
      data_type: timestamp with time zone
      nullable: false
      description: Timestamp of the moment of modification
    primary_key:
      name: modified_log_pkey
      columns:
      - id
    foreign_keys:
    - name: modified_trend_store_part_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: modified
    schema: trend_directory
    description: >
      Stores information on when trend store parts have changed and for what
      timestamp. The information in this table is updated when the data has
      changed and any actions like materialization-state-updating can be
      triggered (using insert, update or delete triggers) from this table,
      because it is decoupled from the data loading processes.
    columns:
    - name: trend_store_part_id
      data_type: integer
      nullable: false
    - name: timestamp
      data_type: timestamp with time zone
      nullable: false
    - name: first
      data_type: timestamp with time zone
      description: Time of the first modification
      nullable: false
    - name: last
      data_type: timestamp with time zone
      description: Time of the last modification
      nullable: false
    primary_key:
      name: modified_pkey
      columns:
      - trend_store_part_id
      - timestamp
    foreign_keys:
    - name: modified_trend_store_part_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: trend_store_part_stats
    schema: trend_directory
    columns:
    - name: trend_store_part_id
      data_type: integer
      nullable: false
    - name: timestamp
      data_type: timestamp with time zone
      nullable: false
    - name: modified
      data_type: timestamp with time zone
      description: Time of the last modification
      nullable: false
    - name: count
      data_type: integer
      nullable: false
    primary_key:
      name: trend_store_part_stats_pkey
      columns:
      - trend_store_part_id
      - timestamp
    foreign_keys:
    - name: trend_store_part_stats_trend_store_part_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE   

- table:
    name: materialization
    schema: trend_directory
    description: |-
      A ``materialization`` is a materialization that uses the data from
      the view registered in the ``src_view`` column to populate the target trend
      store.
    columns:
      - name: id
        data_type: serial
        nullable: false
        description: The unique identifier of this materialization
      - name: dst_trend_store_part_id
        data_type: integer
        nullable: false
        description: The ID of the destination trend_store_part
      - name: processing_delay
        data_type: interval
        nullable: false
        description: >
          The time after the destination timestamp before this materialization
          can be executed
      - name: stability_delay
        data_type: interval
        nullable: false
        description: >
          The time to wait after the most recent modified timestamp before
          the source data is considered 'stable'
      - name: reprocessing_period
        data_type: interval
        nullable: false
        description: >
          The maximum time after the destination timestamp that the materialization
          is allowed to be executed
      - name: enabled
        data_type: bool
        nullable: false
        default: 'false'
        description: >
          Indicates if jobs should be created for this materialization (manual
          execution is always possible)
      - name: description
        data_type: jsonb
        nullable: false
        default: "'{}'"
        description: >
          Gives a description of the function used for the materialization
          in json format
    primary_key:
      name: materialization_pkey
      columns:
      - id
    indexes:
    - name: ix_materialization_uniqueness
      unique: true
      definition: btree (dst_trend_store_part_id)
    foreign_keys:
    - name: materialization_dst_trend_store_id_fkey
      columns:
      - dst_trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: cleanup_for_materialization
    schema: trend_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: trend_directory.materialization
    source: |-
      BEGIN
        EXECUTE format(
          'DROP FUNCTION trend.%I(timestamp with time zone)',
          trend_directory.fingerprint_function_name($1)
        );
      END;

- function:
    name: cleanup_for_materialization
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    arguments:
    - data_type: text
      name: materialization_name
    source: |-
      SELECT trend_directory.cleanup_for_materialization(m)
        FROM trend_directory.materialization m
        WHERE m::text = $1;

- table:
    name: materialization_metrics
    schema: trend_directory
    description: |-
      Metrics on individual materializations.
    columns:
      - name: materialization_id
        data_type: integer
        nullable: false
        description: The ID of the materialization
      - name: execution_count
        data_type: integer
        nullable: false
        default: '0'
      - name: total_duration
        data_type: interval
        nullable: false
        default: "'0s'"
    primary_key:
      name: materialization_metrics_pkey
      columns:
      - materialization_id
    foreign_keys:
    - name: materialization_metrics_materialization_id_fkey
      columns:
      - materialization_id
      references:
        table:
          name: materialization
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: create_metrics_for_materialization
    schema: trend_directory
    return_type: trigger
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      BEGIN
          INSERT INTO trend_directory.materialization_metrics(materialization_id)
          VALUES (NEW.id);

          RETURN NEW;
      END;

- trigger:
    table:
      schema: trend_directory
      name: materialization
    name: create_metrics_on_new_materialization
    function:
      schema: trend_directory
      name: create_metrics_for_materialization
    when: after
    events:
    - insert
    affecteach: row

- function:
    name: to_char
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: trend_directory.materialization
    source: |-
      SELECT trend_store_part.name::text
      FROM trend_directory.trend_store_part
      WHERE trend_store_part.id = $1.dst_trend_store_part_id

- function:
    name: materialization_to_char
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: integer
      name: materialization_id
    source: |-
      SELECT trend_store_part.name::text
        FROM trend_directory.trend_store_part
        JOIN trend_directory.materialization
          ON trend_store_part.id = materialization.dst_trend_store_part_id
        WHERE materialization.id = $1;

- function:
    name: source_fingerprint_sql
    schema: trend_directory
    return_type: text
    description: Returns the query to generate fingerprints for the specified view materialization.
    language: sql
    volatility: stable
    arguments:
    - data_type: integer
      name: materialization_id
    source: |-
        SELECT format('SELECT * FROM trend.%I($1)', trend_directory.materialization_to_char($1) || '_fingerprint');

- function:
    name: source_fingerprint
    schema: trend_directory
    return_type: trend_directory.fingerprint
    description: >
      Returns the fingerprint of the combined states of all sources required to
      calculate the data for the target timestamp.
    language: plpgsql
    volatility: stable
    arguments:
    - data_type: integer
      name: materialization_id
    - data_type: timestamp with time zone
    source: |-
      DECLARE
          result trend_directory.fingerprint;
      BEGIN
          EXECUTE trend_directory.source_fingerprint_sql($1) INTO result USING $2;

          RETURN result;
      END;

- table:
    name: view_materialization
    schema: trend_directory
    description: |-
      A ``view_materialization`` is a materialization that uses the data
      from the view registered in the ``src_view`` column to populate
      the target ``trend_store_part``.
    columns:
      - name: id
        data_type: serial
        nullable: false
        description: The unique identifier of this view materialization
      - name: materialization_id
        data_type: integer
        nullable: false
      - name: src_view
        data_type: text
        nullable: false
    primary_key:
      name: view_materialization_pkey
      columns:
      - id
    indexes:
    - name: ix_view_materialization_uniqueness
      unique: true
      definition: btree (materialization_id)
    foreign_keys:
    - name: view_materialization_materialization_id_fkey
      columns:
      - materialization_id
      references:
        table:
          name: materialization
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: cleanup_for_view_materialization
    schema: trend_directory
    return_type: trigger
    language: plpgsql
    volatility: volatile
    arguments: []
    source: |-
      BEGIN
          EXECUTE format('DROP VIEW %s', OLD.src_view);

          RETURN OLD;
      END;

- trigger:
    table:
      schema: trend_directory
      name: view_materialization
    name: cleanup_on_view_materialization_delete
    function:
      schema: trend_directory
      name: cleanup_for_view_materialization
    when: before
    events:
    - delete
    affecteach: row

- function:
    name: define_materialization
    schema: trend_directory
    return_type: trend_directory.materialization
    language: sql
    description: Define a materialization
    volatility: volatile
    arguments:
      - name: dst_trend_store_part_id
        data_type: integer
      - name: processing_delay
        data_type: interval
      - name: stability_delay
        data_type: interval
      - name: reprocessing_period
        data_type: interval
      - name: description
        data_type: jsonb
    source: |-
      INSERT INTO trend_directory.materialization(dst_trend_store_part_id, processing_delay, stability_delay, reprocessing_period, description)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT DO NOTHING
      RETURNING *;

- function:
    name: undefine_materialization
    schema: trend_directory
    return_type: void
    language: sql
    description: Undefine and remove a materialization
    volatility: volatile
    arguments:
    - name: name
      data_type: name
    source: |-
      SELECT trend_directory."cleanup_for_materialization"($1);
      DELETE FROM trend_directory.materialization
        WHERE materialization::text = $1;

- function:
    name: define_view_materialization
    schema: trend_directory
    return_type: trend_directory.view_materialization
    description: Define a materialization that uses a view as source
    language: sql
    volatility: volatile
    arguments:
      - name: dst_trend_store_part_id
        data_type: integer
      - name: processing_delay
        data_type: interval
      - name: stability_delay
        data_type: interval
      - name: reprocessing_period
        data_type: interval
      - name: src_view
        data_type: regclass
      - name: description
        data_type: jsonb
    source: |-
      INSERT INTO trend_directory.view_materialization(materialization_id, src_view)
      VALUES((trend_directory.define_materialization($1, $2, $3, $4, $6)).id, $5) RETURNING *;

- function:
    name: define_view_materialization
    schema: trend_directory
    return_type: trend_directory.view_materialization
    description: Define a materialization that uses a view as source
    language: sql
    volatility: volatile
    arguments:
      - name: dst_trend_store_part_id
        data_type: integer
      - name: processing_delay
        data_type: interval
      - name: stability_delay
        data_type: interval
      - name: reprocessing_period
        data_type: interval
      - name: src_view
        data_type: regclass
    source: SELECT trend_directory.define_view_materialization($1, $2, $3, $4, $5, '{}'::jsonb);

- table:
    name: function_materialization
    schema: trend_directory
    description: |-
      A ``function_materialization`` is a materialization that uses the data
      from the function registered in the ``src_function`` column to populate
      the target ``trend_store_part``.

      The function must have the form of::
        
        (timestamp with time zone) -> TABLE(
          entity_id integer,
          timestamp timestamp with time zone,
          ...
        )
    columns:
      - name: id
        data_type: serial
        nullable: false
        description: The unique identifier of this function materialization
      - name: materialization_id
        data_type: integer
        nullable: false
      - name: src_function
        data_type: text
        nullable: false
    primary_key:
      name: function_materialization_pkey
      columns:
      - id
    indexes:
    - name: ix_function_materialization_uniqueness
      unique: true
      definition: btree (materialization_id)
    foreign_keys:
    - name: function_materialization_materialization_id_fkey
      columns:
      - materialization_id
      references:
        table:
          name: materialization
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: define_function_materialization
    schema: trend_directory
    return_type: trend_directory.function_materialization
    description: Define a materialization that uses a function as source
    language: sql
    volatility: volatile
    arguments:
      - name: dst_trend_store_part_id
        data_type: integer
      - name: processing_delay
        data_type: interval
      - name: stability_delay
        data_type: interval
      - name: reprocessing_period
        data_type: interval
      - name: src_function
        data_type: regproc
      - name: description
        data_type: jsonb
    source: |-
      INSERT INTO trend_directory.function_materialization(materialization_id, src_function)
      VALUES((trend_directory.define_materialization($1, $2, $3, $4, $6)).id, $5::text)
      ON CONFLICT DO NOTHING
      RETURNING *;

- function:
    name: define_function_materialization
    schema: trend_directory
    return_type: trend_directory.function_materialization
    description: Define a materialization that uses a function as source
    language: sql
    volatility: volatile
    arguments:
      - name: dst_trend_store_part_id
        data_type: integer
      - name: processing_delay
        data_type: interval
      - name: stability_delay
        data_type: interval
      - name: reprocessing_period
        data_type: interval
      - name: src_function
        data_type: regproc
    source: SELECT trend_directory.define_function_materialization($1, $2, $3, $4, $5, '{}'::jsonb)

- function:
    name: cleanup_for_function_materialization
    schema: trend_directory
    return_type: trigger
    language: plpgsql
    volatility: volatile
    arguments: []
    source: |-
      BEGIN
          EXECUTE format('DROP FUNCTION %s', OLD.src_function);

          RETURN OLD;
      END;

- trigger:
    table:
      schema: trend_directory
      name: function_materialization
    name: cleanup_on_function_materialization_delete
    function:
      schema: trend_directory
      name: cleanup_for_function_materialization
    when: before
    events:
    - delete
    affecteach: row

- table:
    name: materialization_state
    schema: trend_directory
    description: >
      Stores the relation between the state of the sources used for the
      materialization and the state of the materialized data, so that from this
      table, it can be decided if a new materialization should be done.
    columns:
    - name: materialization_id
      data_type: integer
      nullable: false
      description: The ID of the materialization type
    - name: timestamp
      data_type: timestamp with time zone
      nullable: false
      description: The timestamp of the materialized (materialization result) data
    - name: source_fingerprint
      data_type: jsonb
      nullable: true
      description: Aggregate state of all sources
    - name: processed_fingerprint
      data_type: jsonb
      nullable: true
      description: >
        Snapshot of the source_fingerprint at the time of
        the most recent materialization
    - name: max_modified
      data_type: timestamp with time zone
      description: Date of last data received
    - name: job_id
      data_type: bigint
      nullable: true
      description: ID of the most recent job for this materialization
    primary_key:
      name: materialization_state_pkey
      columns:
      - materialization_id
      - timestamp
    foreign_keys:
    - name: materialization_state_materialization_id_fkey
      columns:
      - materialization_id
      references:
        table:
          name: materialization
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: function_materialization_state
    schema: trend_directory
    description: >
      Stores the relation between the state of the sources used for the
      materialization and the state of the materialized data, so that from this
      table, it can be decided if a new materialization should be done.
    columns:
    - name: materialization_id
      data_type: integer
      nullable: false
      description: The ID of the materialization type
    - name: timestamp
      data_type: timestamp with time zone
      nullable: false
      description: The timestamp of the materialized (materialization result) data
    - name: source_fingerprint
      data_type: jsonb
      nullable: true
      description: Aggregate state of all sources
    - name: processed_fingerprint
      data_type: jsonb
      nullable: true
      description: >
        Snapshot of the source_fingerprint at the time of
        the most recent materialization
    - name: job_id
      data_type: bigint
      nullable: true
      description: ID of the most recent job for this materialization
    primary_key:
      name: function_materialization_state_pkey
      columns:
      - materialization_id
      - timestamp
    foreign_keys:
    - name: materialization_state_materialization_id_fkey
      columns:
      - materialization_id
      references:
        table:
          name: function_materialization
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: max_modified
    schema: trend_directory
    return_type: timestamp with time zone
    arguments:
    - data_type: integer
      name: dst_trend_store_part_id
    - data_type: timestamp with time zone
    language: sql
    volatility: stable
    source: |-
        SELECT max(last) FROM trend_directory.modified
          WHERE trend_store_part_id = $1
          AND timestamp < $2;

- function:
    name: update_source_fingerprint
    schema: trend_directory
    return_type: void
    description: Update the fingerprint of the sources in the materialization_state table.
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: materialization_id
    - data_type: timestamp with time zone
    source: |-
      DECLARE
        materialization trend_directory.materialization;
        fingerprint trend_directory.fingerprint := trend_directory.source_fingerprint($1, $2);
      BEGIN
        SELECT * FROM trend_directory.materialization WHERE id = $1 INTO materialization;
        IF action_count(format('SELECT * FROM trend_directory.materialization_state WHERE materialization_id = %s AND timestamp = ''%s''', $1, $2)) = 0
          THEN INSERT INTO trend_directory.materialization_state(materialization_id, timestamp, source_fingerprint, max_modified, processed_fingerprint, job_id)
            VALUES ($1, $2, fingerprint.body, fingerprint.modified, null, null);
          ELSE UPDATE trend_directory.materialization_state ms SET source_fingerprint = fingerprint.body, max_modified = fingerprint.modified WHERE ms.materialization_id = $1 AND ms.timestamp = $2;
        END IF;
      END;

- table:
    name: materialization_tag_link
    schema: trend_directory
    description: |-
      Links tags to materializations. Examples of tags to link to a materialization
      might be: online, offline, aggregation, kpi, etc.
    columns:
    - name: materialization_id
      data_type: integer
      nullable: false
    - name: tag_id
      data_type: integer
      nullable: false
    primary_key:
      name: materialization_tag_link_pkey
      columns:
      - materialization_id
      - tag_id
    foreign_keys:
    - name: materialization_tag_link_tag_id_fkey
      columns:
      - tag_id
      references:
        table:
          name: tag
          schema: directory
        columns:
        - id
      on_delete: cascade
    - name: materialization_tag_link_materialization_id_fkey
      columns:
      - materialization_id
      references:
        table:
          name: materialization
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: materialization_trend_store_link
    schema: trend_directory
    description: >
      Stores the dependencies between a materialization and its source table trend
      store parts. Multiple levels of views and functions may exist between a
      materialization and its source table trend stores. These intermediate views and
      functions are not registered here, but only the table trend stores containing
      the actual source data used in the view.

      The timestamp_mapping_func column stores the function to map a timestamp
      of the source (trend_store_part) to a timestamp of the target (the
      view and target trend_store_part).
    columns:
    - name: materialization_id
      data_type: integer
      nullable: false
      description: Reference to a materialization.
    - name: trend_store_part_id
      data_type: integer
      nullable: false
      description: >
        Reference to a trend_store_part that is a source of the
        materialization referenced by materialization_id.
    - name: timestamp_mapping_func
      data_type: regprocedure
      nullable: false
      description: >
        The function that maps timestamps in the source table to timestamps in
        the materialized data. For example, for a view for an hour aggregation from 15 minute
        granularity data will need to map 4 timestamps in the source to 1 timestamp in
        the resulting data.
    foreign_keys:
    - name: materialization_trend_store_link_materialization_id_fkey
      columns:
      - materialization_id
      references:
        table:
          name: materialization
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    - name: materialization_trend_store_link_trend_store_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    primary_key:
      name: materialization_trend_store_link_pkey
      columns:
      - materialization_id
      - trend_store_part_id
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: completeness
    schema: trend_directory
    return_type: TABLE("timestamp" timestamptz, "count" bigint)
    description: Return table with record counts grouped by timestamp
    language: plpgsql
    volatility: volatile
    arguments:
      - data_type: name
      - name: start
        data_type: timestamp with time zone
      - name: end
        data_type: timestamp with time zone
    source: |-
        DECLARE
            gran interval;
            truncated_start timestamptz;
            truncated_end timestamptz;
        BEGIN
            SELECT granularity INTO gran
            FROM trend_directory.trend_store_part tsp
            JOIN trend_directory.trend_store ts ON ts.id = tsp.trend_store_id
            WHERE tsp.name = $1;

            CASE gran
            WHEN '1month' THEN
                SELECT date_trunc('month', $2) INTO truncated_start;
                SELECT date_trunc('month', $3) INTO truncated_end;
            WHEN '1w' THEN
                SELECT date_trunc('week', $2) INTO truncated_start;
                SELECT date_trunc('week', $3) INTO truncated_end;
            WHEN '1d' THEN
                SELECT date_trunc('day', $2) INTO truncated_start;
                SELECT date_trunc('day', $3) INTO truncated_end;
            WHEN '1h' THEN
                SELECT date_trunc('hour', $2) INTO truncated_start;
                SELECT date_trunc('hour', $3) INTO truncated_end;
            ELSE
                SELECT trend_directory.index_to_timestamp(gran, trend_directory.timestamp_to_index(gran, $2)) INTO truncated_start;
                SELECT trend_directory.index_to_timestamp(gran, trend_directory.timestamp_to_index(gran, $3)) INTO truncated_end;
            END CASE;

            RETURN QUERY
            WITH trend_data AS (
                SELECT s.timestamp, s.count from trend_directory.trend_store_part_stats s
                JOIN trend_directory.trend_store_part p ON s.trend_store_part_id = p.id
                WHERE s.timestamp >= truncated_start and s.timestamp <= truncated_end and p.name = $1
            )
            SELECT t, coalesce(d.count, 0)::bigint
                FROM generate_series(truncated_start, truncated_end, gran) t
                LEFT JOIN trend_data d on d.timestamp = t ORDER BY t asc;
        END;

- function:
    name: map_timestamp
    schema: trend_directory
    return_type: timestamp with time zone
    description: Map timestamp using the mapping function defined in the link
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: materialization_id
    - data_type: integer
      name: trend_store_part_id
    - data_type: timestamp with time zone
    source: |-
      DECLARE
        mts_link trend_directory.materialization_trend_store_link;
        result timestamp with time zone;
      BEGIN
        SELECT * FROM trend_directory.materialization_trend_store_link tsl WHERE tsl.materialization_id = $1 AND tsl.trend_store_part_id = $2 INTO mts_link;
        EXECUTE format('SELECT %s($1)', mts_link.timestamp_mapping_func::regproc::name) INTO result USING $3;
        RETURN result;
      END;

- function:
    name: update_materialization_state
    schema: trend_directory
    return_type: bigint
    language: sql
    volatility: volatile
    arguments:
      - data_type: integer
      - data_type: timestamp with time zone
    source: |-
      SELECT count(*) FROM (
          WITH mapped_modified AS (
            SELECT
              materialization_id,
              trend_directory.map_timestamp(materialization_trend_store_link.materialization_id, materialization_trend_store_link.trend_store_part_id, $2) AS dst_timestamp
            FROM trend_directory.materialization_trend_store_link
            WHERE trend_store_part_id = $1
          )
          SELECT trend_directory.update_source_fingerprint(m.id, dst_timestamp)
          FROM mapped_modified
          JOIN trend_directory.materialization m ON m.id = materialization_id
          GROUP BY m.id, dst_timestamp
      ) update_result;

- function:
    name: new_modified
    schema: trend_directory
    return_type: trigger
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      BEGIN
          PERFORM "trend_directory"."update_materialization_state"(NEW.trend_store_part_id, NEW.timestamp);

          RETURN NEW;
      END;

- trigger:
    table:
      schema: trend_directory
      name: modified
    name: update_materialization_state_on_new_modified
    function:
      schema: trend_directory
      name: new_modified
    when: after
    events:
    - insert
    - update
    affecteach: row

- function:
    name: base_table_schema
    schema: trend_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT 'trend'::name;

- function:
    name: staging_table_schema
    schema: trend_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT 'trend'::name;

- function:
    name: view_schema
    schema: trend_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT 'trend'::name;

- function:
    name: granularity_to_text
    schema: trend_directory
    return_type: text
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - data_type: interval
    source: |-
      SELECT CASE $1
          WHEN '300'::interval THEN
              '5m'
          WHEN '900'::interval THEN
              'qtr'
          WHEN '1 hour'::interval THEN
              'hr'
          WHEN '12 hours'::interval THEN
              '12hr'
          WHEN '1 day'::interval THEN
              'day'
          WHEN '1 week'::interval THEN
              'wk'
          WHEN '1 month'::interval THEN
              'month'
          ELSE
              $1::text
          END;

- function:
    name: base_table_name
    schema: trend_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT $1.name;

- function:
    name: base_table_name_by_trend_store_part_id
    schema: trend_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - data_type: integer
      name: trend_store_part_id
    source: |-
      SELECT name FROM trend_directory.trend_store_part
        WHERE id = $1;

- function:
    name: view_name
    schema: trend_directory
    return_type: name
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_view_part
    source: |-
      SELECT $1.name;

- function:
    name: fingerprint_function_name
    schema: trend_directory
    return_type: name
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.materialization
    source: |-
      SELECT format('%s_fingerprint', trend_directory.materialization_to_char($1.id))::name;

- function:
    name: to_char
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT $1.name::text;

- function:
    name: to_char
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: trend_directory.trend_view_part
    source: |-
      SELECT $1.name::text;

- function:
    name: get_trend_view
    schema: trend_directory
    return_type: trend_directory.trend_view
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    - name: granularity
      data_type: interval
    source: |-
      SELECT ts
          FROM trend_directory.trend_view ts
          JOIN directory.data_source ds ON ds.id = ts.data_source_id
          JOIN directory.entity_type et ON et.id = ts.entity_type_id
          WHERE lower(ds.name) = lower($1) AND lower(et.name) = lower($2) AND ts.granularity = $3;

- function:
    name: partition_schema
    schema: trend_directory
    return_type: name
    language: sql
    volatility: immutable
    arguments: []
    source: |-
      SELECT 'trend_partition'::name;

- function:
    name: partition_name
    schema: trend_directory
    return_type: name
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: integer
    source: |-
      SELECT format('%s_%s', trend_directory.base_table_name($1), $2)::name;

- function:
    name: index_to_timestamp
    schema: trend_directory
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - name: partition_size
      data_type: interval
    - name: index
      data_type: integer
    source: |-
      SELECT to_timestamp(extract(epoch from $1) * $2);

- function:
    name: timestamp_to_index
    schema: trend_directory
    return_type: integer
    language: sql
    volatility: stable
    arguments:
    - data_type: interval
    - data_type: timestamp with time zone
    source: |-
      SELECT extract(epoch from $2)::integer / extract(epoch from $1)::integer;

- function:
    name: timestamp_to_index
    schema: trend_directory
    return_type: integer
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.trend_store
    - data_type: timestamp with time zone
    source: |-
      SELECT trend_directory.timestamp_to_index($1.partition_size, $2);

- function:
    name: create_partition_sql
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: integer
    source: |-
      SELECT ARRAY[
          format(
              'CREATE TABLE %I.%I '
              'PARTITION OF %I.%I '
              'FOR VALUES FROM (''%s'') TO (''%s'')',
              trend_directory.partition_schema(),
              trend_directory.partition_name($1, $2),
              trend_directory.base_table_schema(),
              trend_directory.base_table_name($1),
              trend_directory.index_to_timestamp(trend_store.partition_size, $2),
              trend_directory.index_to_timestamp(trend_store.partition_size, $2 + 1)
          )
      ]
      FROM trend_directory.trend_store WHERE id = $1.trend_store_id;

- function:
    name: get_partition_size
    schema: trend_directory
    return_type: interval
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT partition_size FROM trend_directory.trend_store WHERE trend_store.id = $1.trend_store_id;

- function:
    name: create_partition
    schema: trend_directory
    return_type: trend_directory.partition
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: integer
    source: |-
      DECLARE
        result trend_directory.partition;
      BEGIN
        PERFORM public.action($1, trend_directory.create_partition_sql($1, $2));

        INSERT INTO trend_directory.partition(trend_store_part_id, index, name, "from", "to")
          SELECT $1.id, $2, trend_directory.partition_name($1, $2), trend_directory.index_to_timestamp(trend_store.partition_size, $2), trend_directory.index_to_timestamp(trend_store.partition_size, $2 + 1)
          FROM trend_directory.trend_store WHERE id = $1.trend_store_id
          RETURNING * INTO result;
        RETURN result;
      END;

- function:
    name: create_partition
    schema: trend_directory
    return_type: trend_directory.partition
    language: sql
    volatility: volatile
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: timestamp with time zone
    source: |-
      SELECT trend_directory.create_partition($1, trend_directory.timestamp_to_index(trend_directory.get_partition_size($1), $2));

- function:
    name: create_partition
    schema: trend_directory
    return_type: trend_directory.partition
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: trend_store_part_id
    - data_type: integer
    source: |-
      DECLARE
        tsp trend_directory.trend_store_part;
      BEGIN
        SELECT * FROM trend_directory.trend_store_part WHERE id = $1 INTO tsp;
        RETURN trend_directory.create_partition(tsp, $2);
      END;

- function:
    name: column_spec
    schema: trend_directory
    return_type: text
    language: sql
    volatility: immutable
    arguments:
    - data_type: trend_directory.table_trend
    source: |-
      SELECT format('%I %s', $1.name, $1.data_type);

- function:
    name: trend_column_spec
    schema: trend_directory
    return_type: text
    language: plpgsql
    volatility: immutable
    arguments:
    - name: table_trend_id
      data_type: integer
    source: |-
      DECLARE
        tt trend_directory.table_trend;
      BEGIN
        SELECT * FROM trend_directory.table_trend WHERE id = $1 INTO tt;
        RETURN trend_directory.column_spec(tt);
      END;

- function:
    name: column_spec
    schema: trend_directory
    return_type: text
    language: sql
    volatility: immutable
    arguments:
    - data_type: trend_directory.generated_table_trend
    source: |-
        SELECT format('%I %s GENERATED ALWAYS AS (%s) STORED', $1.name, $1.data_type, $1.expression);

- function:
    name: generated_trend_column_spec
    schema: trend_directory
    return_type: text
    language: plpgsql
    volatility: immutable
    arguments:
    - name: generated_table_trend_id
      data_type: integer
    source: |-
      DECLARE
        tt trend_directory.generated_table_trend;
      BEGIN
        SELECT * FROM trend_directory.generated_table_trend WHERE id = $1 INTO tt;
        RETURN trend_directory.column_spec(tt);
      END;

- function:
    name: column_specs
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT array_agg(c) FROM (
        SELECT trend_directory.trend_column_spec(t.id) AS c
        FROM trend_directory.table_trend t
        WHERE t.trend_store_part_id = $1.id
        UNION ALL
        SELECT trend_directory.generated_trend_column_spec(t.id) AS c
        FROM trend_directory.generated_table_trend t
        WHERE t.trend_store_part_id = $1.id
      ) combined_columns;

- function:
    name: create_base_table_sql
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT ARRAY[
          format(
              'CREATE TABLE %I.%I ('
              'entity_id integer NOT NULL, '
              '"timestamp" timestamp with time zone NOT NULL, '
              'created timestamp with time zone NOT NULL, '
              '%s'
              ') PARTITION BY RANGE ("timestamp");',
              trend_directory.base_table_schema(),
              trend_directory.base_table_name($1),
              array_to_string(ARRAY['job_id bigint NOT NULL'] || trend_directory.column_specs($1), ',')
          ),
          format(
              'ALTER TABLE %I.%I ADD PRIMARY KEY (entity_id, "timestamp");',
              trend_directory.base_table_schema(),
              trend_directory.base_table_name($1)
          ),
          format(
              'CREATE INDEX ON %I.%I USING btree (job_id)',
              trend_directory.base_table_schema(),
              trend_directory.base_table_name($1)
          ),
          format(
              'CREATE INDEX ON %I.%I USING btree (timestamp);',
              trend_directory.base_table_schema(),
              trend_directory.base_table_name($1)
          ),
          format(
              'SELECT create_distributed_table(''%I.%I'', ''entity_id'')',
              trend_directory.base_table_schema(),
              trend_directory.base_table_name($1)
          )
      ];

- function:
    name: create_base_table
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: true
    secdef: true
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT public.action($1, trend_directory.create_base_table_sql($1))

- function:
    name: drop_base_table_sql
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT format(
          'DROP TABLE %I.%I',
          trend_directory.base_table_schema(),
          trend_directory.base_table_name($1)
      );

- function:
    name: drop_base_table
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT public.action($1, trend_directory.drop_base_table_sql($1))

- function:
    name: staging_table_name
    schema: trend_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT (trend_directory.base_table_name($1) || '_staging')::name;

- function:
    name: create_staging_table_sql
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT ARRAY[
          format(
              'CREATE UNLOGGED TABLE %I.%I (entity_id integer, "timestamp" timestamp with time zone, created timestamp with time zone, job_id bigint%s);',
              trend_directory.staging_table_schema(),
              trend_directory.staging_table_name($1),
              (
                  SELECT string_agg(format(', %I %s', t.name, t.data_type), ' ')
                  FROM trend_directory.table_trend t
                  WHERE t.trend_store_part_id = $1.id
              )
          ),
          format(
              'ALTER TABLE ONLY %I.%I ADD PRIMARY KEY (entity_id, "timestamp");',
              trend_directory.staging_table_schema(),
              trend_directory.staging_table_name($1)
          )
      ];

- function:
    name: create_staging_table
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: true
    secdef: true
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT public.action($1, trend_directory.create_staging_table_sql($1));

- function:
    name: drop_staging_table_sql
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT format(
          'DROP TABLE %I.%I',
          trend_directory.staging_table_schema(),
          trend_directory.staging_table_name($1)
      );

- function:
    name: drop_staging_table
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: true
    secdef: true
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT public.action($1, trend_directory.drop_staging_table_sql($1));

- function:
    name: initialize_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    description: 'Create all database objects required for the trend store part to
      be fully functional and capable of storing data.'
    source: |-
      SELECT trend_directory.create_base_table($1);
      SELECT trend_directory.create_staging_table($1);
      
      SELECT $1;

- function:
    name: initialize_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: integer
    source: |-
      DECLARE
        tsp trend_directory.trend_store_part;
      BEGIN
        SELECT * from trend_directory.trend_store_part WHERE id = $1 into tsp;
        PERFORM trend_directory.initialize_trend_store_part(tsp);
        RETURN tsp;
      END;

- function:
    name: deinitialize_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    description: |-
      Remove all database objects related to the table trend store part
    source: |-
      SELECT trend_directory.drop_base_table($1);
      SELECT trend_directory.drop_staging_table($1);

- function:
    name: deinitialize_trend_store_part
    schema: trend_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: integer
      name: trend_store_part_id
    source: |-
      DECLARE
        tsp trend_directory.trend_store_part;
      BEGIN
        SELECT * FROM trend_directory.trend_store_part
          WHERE trend_store_part.id = $1 INTO tsp;
        EXECUTE trend_directory.drop_base_table_sql(tsp);
        EXECUTE trend_directory.drop_staging_table_sql(tsp);
      END;
    
- function:
    name: get_default_partition_size
    schema: trend_directory
    return_type: interval
    language: sql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - name: granularity
      data_type: interval
    description: Return the default partition size in seconds for a particular granularity
    source: |-
      SELECT CASE $1
          WHEN '300'::interval THEN
              '3 hours'::interval
          WHEN '900'::interval THEN
              '6 hours'::interval
          WHEN '1800'::interval THEN
              '6 hours'::interval
          WHEN '1 hour'::interval THEN
              '1 day'::interval
          WHEN '12 hours'::interval THEN
              '7 days'::interval
          WHEN '1 day'::interval THEN
              '7 days'::interval
          WHEN '1 week'::interval THEN
              '1 month'::interval
          WHEN '1 month'::interval THEN
              '1 year'::interval
          END;

- function:
    name: define_table_trend
    schema: trend_directory
    return_type: trend_directory.table_trend
    language: sql
    volatility: volatile
    arguments:
    - name: trend_store_part_id
      data_type: integer
    - data_type: trend_directory.trend_descr
    source: |-
      INSERT INTO trend_directory.table_trend (trend_store_part_id, name, data_type, description, time_aggregation, entity_aggregation)
      VALUES ($1, $2.name, $2.data_type, $2.description, $2.time_aggregation, $2.entity_aggregation);
      SELECT * FROM trend_directory.table_trend WHERE trend_store_part_id = $1 AND name = $2.name;

- function:
    name: define_generated_table_trend
    schema: trend_directory
    return_type: trend_directory.generated_table_trend
    language: sql
    volatility: volatile
    arguments:
    - name: trend_store_part_id
      data_type: integer
    - data_type: trend_directory.generated_trend_descr
    source: |-
      INSERT INTO trend_directory.generated_table_trend (trend_store_part_id, name, data_type, expression, extra_data, description)
      VALUES ($1, $2.name, $2.data_type, $2.expression, $2.extra_data, $2.description);
      SELECT * FROM trend_directory.generated_table_trend WHERE trend_store_part_id = $1 AND name = $2.name;

- function:
    name: define_trend_view
    schema: trend_directory
    return_type: trend_directory.trend_view
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.data_source
    - data_type: directory.entity_type
    - name: granularity
      data_type: interval
    source: |-
      INSERT INTO trend_directory.trend_view (
          data_source_id,
          entity_type_id,
          granularity
      )
      VALUES (
          $1.id,
          $2.id,
          $3
      ) RETURNING *;

- function:
    name: create_view_sql
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_view_part
    - name: sql
      data_type: text
    source: |-
      SELECT ARRAY[
          format('CREATE VIEW %I.%I AS %s;', trend_directory.view_schema(), trend_directory.view_name($1), $2)
      ];

- function:
    name: get_view_trends
    schema: trend_directory
    return_type: trend_directory.trend_descr
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: view_name
      data_type: name
    source: |-
      SELECT (a.attname, format_type(a.atttypid, a.atttypmod), 'deduced from view', 'sum', 'sum', '{}')::trend_directory.trend_descr
      FROM pg_class c
      JOIN pg_attribute a ON a.attrelid = c.oid
      WHERE c.relname = $1 AND a.attnum >= 0 AND NOT a.attisdropped;

- function:
    name: show_trends
    schema: trend_directory
    return_type: trend_directory.trend_descr
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT
          table_trend.name::name,
          format_type(a.atttypid, a.atttypmod)::text,
          table_trend.description,
          table_trend.time_aggregation,
          table_trend.entity_aggregation,
          table_trend.extra_data
      FROM trend_directory.table_trend
      JOIN pg_catalog.pg_class c ON c.relname = $1::text
      JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
      JOIN pg_catalog.pg_attribute a ON a.attrelid = c.oid AND a.attname = table_trend.name
      WHERE
          n.nspname = 'trend' AND
          a.attisdropped = false AND
          a.attnum > 0 AND table_trend.trend_store_part_id = $1.id;

- function:
    name: initialize_trend_view_part
    schema: trend_directory
    return_type: trend_directory.trend_view_part
    language: sql
    volatility: volatile
    strict: false
    secdef: true
    arguments:
    - data_type: trend_directory.trend_view_part
    - name: query
      data_type: text
    source: |-
      SELECT public.action($1, trend_directory.create_view_sql($1, $2));

      SELECT $1;

- function:
    name: initialize_trend_view
    schema: trend_directory
    return_type: trend_directory.trend_view
    language: sql
    volatility: volatile
    strict: false
    secdef: true
    arguments:
    - data_type: trend_directory.trend_view
    - data_type: trend_directory.trend_view_part_descr[]
    source: |-
      SELECT $1;

- function:
    name: create_trend_view
    schema: trend_directory
    return_type: trend_directory.trend_view
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    - name: granularity
      data_type: interval
    - data_type: trend_directory.trend_view_part_descr[]
    source: |-
      DECLARE
        dsource directory.data_source;
        etype directory.entity_type;
      BEGIN
        SELECT directory.name_to_data_source($1) into dsource;
        SELECT directory.name_to_entity_type($2) into etype;
        RETURN trend_directory.initialize_trend_view(
          trend_directory.define_trend_view(dsource, etype, $3), $4
        );
      END;

- function:
    name: define_table_trends
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: trend_directory.trend_descr[]
    source: |-
      BEGIN
        INSERT INTO trend_directory.table_trend(name, data_type, trend_store_part_id, description, time_aggregation, entity_aggregation, extra_data) (
          SELECT name, data_type, $1.id, description, time_aggregation, entity_aggregation, extra_data
          FROM unnest($2)
        );
        RETURN $1;
      END;

- function:
    name: define_generated_table_trends
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: trend_directory.generated_trend_descr[]
    source: |-
      BEGIN
        INSERT INTO trend_directory.generated_table_trend(trend_store_part_id, name, data_type, expression, extra_data, description) (
          SELECT $1.id, name, data_type, expression, extra_data, description
          FROM unnest($2)
        );

        RETURN $1;
      END;

- function:
    name: rename_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: name
    source: |-
      BEGIN
        EXECUTE format(
          'ALTER TABLE %I.%I RENAME TO %I',
          trend_directory.base_table_schema(),
          $1.name,
          $2
        );
        RETURN $1;
      END; 

- function:
    name: rename_partitions
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - name: new_name
      data_type: name
    source: |-
      DECLARE
        partition trend_directory.partition;
      BEGIN
        FOR partition in SELECT * FROM trend_directory.partition WHERE trend_store_part_id = $1.id
        LOOP
          EXECUTE format(
              'ALTER TABLE trend_partition.%I RENAME TO %I',
              partition.name,
              $2 || '_' || partition.index
          );
          EXECUTE format(
              'UPDATE trend_directory.partition SET name = ''%s'' WHERE id = %s',
              $2 || '_' || partition.index,
              partition.id
          );
        END LOOP;
        RETURN $1;
      END;

- function:
    name: rename_trend_store_part_full
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: name
    source: |-
      DECLARE
        old_name text;
        new_name text;
      BEGIN
        SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
        SELECT trend_directory.to_char($1) INTO old_name;
        SELECT $2::text INTO new_name;
        PERFORM trend_directory.rename_trend_store_part($1, $2);
        EXECUTE format(
            'ALTER TABLE %I.%I RENAME TO %I',
            trend_directory.staging_table_schema(),
            old_name || '_staging',
            new_name || '_staging'
        );
        PERFORM trend_directory.rename_partitions($1, $2);
        EXECUTE format(
            'UPDATE trend_directory.view_materialization '
            'SET src_view = ''%s'' '
            'WHERE src_view = ''%s''',
            'trend."_' || new_name || '"',
            'trend."_' || old_name || '"'
        );
        EXECUTE format(
            'UPDATE trend_directory.function_materialization '
            'SET src_function = ''%s'' '
            'WHERE src_function = ''%s''',
            'trend."' || new_name || '"',
            'trend."' || old_name || '"'
        );
        RETURN $1;
      END

- function:
    name: get_index_on
    schema: trend_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: name
    - data_type: name
    source: |-
      SELECT
              i.relname
      FROM
              pg_class t,
              pg_class i,
              pg_index ix,
              pg_attribute a
      WHERE
              t.oid = ix.indrelid
              and i.oid = ix.indexrelid
              and a.attrelid = t.oid
              and a.attnum = ANY(ix.indkey)
              and t.relkind = 'r'
              and t.relname = $1
              and a.attname = $2;

- function:
    name: trend_store
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      SELECT *
      FROM trend_directory.trend_store
      WHERE id = $1.trend_store_id;

- function:
    name: get_trend_store
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    - name: granularity
      data_type: interval
    source: |-
      SELECT ts
      FROM trend_directory.trend_store ts
      JOIN directory.data_source ds ON ds.id = ts.data_source_id
      JOIN directory.entity_type et ON et.id = ts.entity_type_id
      WHERE
          lower(ds.name) = lower($1) AND
          lower(et.name) = lower($2) AND
          ts.granularity = $3;

- function:
    name: get_trend_store_id
    schema: trend_directory
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    source: SELECT $1.id;
        
- function:
    name: define_trend_store
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.data_source
    - data_type: directory.entity_type
    - name: granularity
      data_type: interval
    - name: partition_size
      data_type: interval
    source: |-
      INSERT INTO trend_directory.trend_store (
          data_source_id,
          entity_type_id,
          granularity,
          partition_size
      )
      VALUES (
          $1.id,
          $2.id,
          $3,
          $4
      ) RETURNING *;

- function:
    name: delete_trend_store
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: integer
    source: |-
      SELECT trend_directory.deinitialize_trend_store_part(part.id)
      FROM trend_directory.trend_store_part AS part
      WHERE trend_store_id = $1;

      DELETE FROM trend_directory.trend_store WHERE id = $1;

- function:
    name: delete_trend_store
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    - name: granularity
      data_type: interval
    source: |-
      SELECT trend_directory.delete_trend_store((trend_directory.get_trend_store($1, $2, $3)).id);

- function:
    name: delete_trend_store_part
    schema: trend_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      DECLARE
          table_name text;
      BEGIN

          EXECUTE format(
              'DROP TABLE IF EXISTS trend.%I CASCADE',
              trend_directory.base_table_name($1)
          );

          DELETE FROM trend_directory.trend_store_part tp WHERE tp.id = $1.id;
      END;

- function:
    name: initialize_trend_store
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    source: |-
      SELECT trend_directory.initialize_trend_store_part(trend_store_part.id)
      FROM trend_directory.trend_store_part WHERE trend_store_id = $1.id;

      SELECT $1;

- function:
    name: define_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    - name: name
      data_type: name
    source: |-
      INSERT INTO trend_directory.trend_store_part (trend_store_id, name)
      VALUES ($1, $2)
      RETURNING *;

- function:
    name: define_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    - name: name
      data_type: name
    - name: trends
      data_type: trend_directory.trend_descr[]
    - name: generated_trends
      data_type: trend_directory.generated_trend_descr[]
    source: |-
      SELECT 
      trend_directory.define_generated_table_trends(
        trend_directory.define_table_trends(
            trend_directory.define_trend_store_part($1, $2),
            $3
        ),
        $4
      );

- function:
    name: create_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    - name: name
      data_type: name
    source: |-
      SELECT trend_directory.initialize_trend_store_part(
          trend_directory.define_trend_store_part($1, $2)
        );

- function:
    name: get_trend_store_parts
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    source: |-
      SELECT trend_store_part FROM trend_directory.trend_store_part WHERE trend_store_id = $1;

- function:
    name: get_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    - name: name
      data_type: name
    source: |-
      SELECT * FROM trend_directory.trend_store_part WHERE trend_store_id = $1 AND name = $2;

- function:
    name: get_trend_store_part_id
    schema: trend_directory
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: SELECT $1.id;

- function:
    name: get_or_create_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    - name: name
      data_type: name
    source: |-
      SELECT COALESCE(
        trend_directory.get_trend_store_part($1, $2),
        trend_directory.create_trend_store_part($1, $2)
      );

- function:
    name: add_missing_trend_store_parts
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      SELECT trend_directory.get_or_create_trend_store_part($1.id, name)
        FROM unnest($2);
      SELECT $1;

- function:
    name: define_trend_store
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - data_type: trend_directory.trend_store_part_descr[]
    source: |-
      SELECT trend_directory.define_trend_store_part($1.id, name, trends, generated_trends)
      FROM unnest($2);

      SELECT $1;

- function:
    name: define_trend_store
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: directory.data_source
    - data_type: directory.entity_type
    - name: granularity
      data_type: interval
    - name: partition_size
      data_type: interval
    - name: trends
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      SELECT trend_directory.define_trend_store(
          trend_directory.define_trend_store($1, $2, $3, $4),
          $5
      );

- function:
    name: create_trend_store
    schema: trend_directory
    return_type: trend_directory.trend_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    - name: granularity
      data_type: interval
    - name: partition_size
      data_type: interval
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        dsource directory.data_source;
        etype directory.entity_type;
      BEGIN
        SELECT * FROM directory.name_to_data_source($1) into dsource;
        SELECT * FROM directory.name_to_entity_type($2) into etype;
        RETURN trend_directory.initialize_trend_store(
          trend_directory.define_trend_store(dsource, etype, $3, $4, $5)
        );
      END;

- function:
    name: staged_timestamps
    schema: trend_directory
    return_type: timestamp with time zone
    returns_set: true
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part
    source: |-
      BEGIN
          RETURN QUERY EXECUTE format(
              'SELECT timestamp FROM %I.%I GROUP BY timestamp',
              trend_directory.staging_table_schema(),
              trend_directory.staging_table_name(part)
          );
      END;

- function:
    name: transfer_staged
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_part
      data_type: trend_directory.trend_store_part
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      DECLARE
          row_count integer;
      BEGIN
          EXECUTE format(
              'INSERT INTO %I.%I SELECT * FROM %I.%I WHERE timestamp = $1',
              trend_directory.base_table_schema(),
              trend_directory.base_table_name(trend_store_part),
              trend_directory.staging_table_schema(),
              trend_directory.staging_table_name(trend_store_part)
          ) USING timestamp;

          GET DIAGNOSTICS row_count = ROW_COUNT;

          RETURN row_count;
      END;

- function:
    name: transfer_staged
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_part
      data_type: trend_directory.trend_store_part
    source: |-
      SELECT
          trend_directory.transfer_staged(trend_store_part, timestamp)
      FROM trend_directory.staged_timestamps(trend_store_part) timestamp;

      SELECT public.action(
          $1,
          format(
              'TRUNCATE %I.%I',
              trend_directory.staging_table_schema(),
              trend_directory.staging_table_name(trend_store_part)
          )
      );

- function:
    name: changes_on_trend_update
    schema: trend_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_directory.table_trend_id
      data_type: integer
    - name: oldname
      data_type: text
    - name: newname
      data_type: text
    source: |-
      DECLARE
          base_table_name text;
      BEGIN
          IF $3 <> $2 THEN
              FOR base_table_name IN
                  SELECT trend_directory.base_table_name_by_trend_store_part_id(trend_store_part.id)
                  FROM trend_directory.table_trend
                  JOIN trend_directory.trend_store_part ON table_trend.trend_store_part_id = trend_store_part.id
                  WHERE table_trend.id = $1
              LOOP
                  EXECUTE format('ALTER TABLE trend.%I RENAME COLUMN %I TO %I', base_table_name, $2, $3);
              END LOOP;
          END IF;
      END;

- function:
    name: alter_trend_name
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - name: trend_name
      data_type: name
    - name: new_name
      data_type: name
    source: |-
      DECLARE
        table_trend_id integer;
      BEGIN
        FOR table_trend_id IN
          SELECT id FROM trend_directory.table_trend WHERE trend_store_part_id = $1.id AND name = $2
        LOOP
          UPDATE trend_directory.table_trend SET name = $3 WHERE id = table_trend_id;
          PERFORM trend_directory.changes_on_trend_update(table_trend_id, $2, $3);
        END LOOP;
        RETURN $1;
      END;

- composite_type:
    name: column_info
    schema: trend_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false

- function:
    name: table_columns
    schema: trend_directory
    return_type: trend_directory.column_info
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: namespace
      data_type: name
    - name: table
      data_type: name
    source: |-
      SELECT
          a.attname,
          format_type(a.atttypid, a.atttypmod)
      FROM
          pg_catalog.pg_class c
      JOIN
          pg_catalog.pg_namespace n ON c.relnamespace = n.oid
      JOIN
          pg_catalog.pg_attribute a ON a.attrelid = c.oid
      WHERE
          n.nspname = $1 AND
          c.relname = $2 AND
          a.attisdropped = false AND
          a.attnum > 0;

- function:
    name: table_columns
    schema: trend_directory
    return_type: trend_directory.column_info
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: oid
    source: |-
      SELECT
          a.attname,
          format_type(a.atttypid, a.atttypmod)
      FROM
          pg_catalog.pg_class c
      JOIN
          pg_catalog.pg_attribute a ON a.attrelid = c.oid
      WHERE
          c.oid = $1 AND
          a.attisdropped = false AND
          a.attnum > 0;

- function:
    name: drop_view_sql
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_view_part
    source: |-
      SELECT format(
          'DROP VIEW IF EXISTS %I.%I',
          trend_directory.view_schema(),
          trend_directory.view_name($1)
      );

- function:
    name: drop_view
    schema: trend_directory
    return_type: trend_directory.trend_view_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_view_part
    source: |-
      SELECT public.action($1, trend_directory.drop_view_sql($1));

      SELECT $1;

- function:
    name: delete_trend_view
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_view
    source: |-
      SELECT trend_directory.drop_view(tvp)
        FROM trend_directory.trend_view_part tvp
        WHERE tvp.trend_view_id = $1.id;
      DELETE FROM trend_directory.trend_view WHERE id = $1.id;

- function:
    name: add_column_sql_part
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.table_trend
    source: |-
      SELECT format('ADD COLUMN %I %s', $1.name, $1.data_type);

- function:
    name: add_trends_to_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: trend_directory.table_trend[]
    source: |-
      SELECT public.action(
        $1,
        ARRAY[
          format(
            'ALTER TABLE %I.%I %s;',
            trend_directory.base_table_schema(),
            trend_directory.base_table_name($1),
            (SELECT string_agg(trend_directory.add_column_sql_part(t), ',') FROM unnest($2) AS t)
          ),
          format(
            'ALTER TABLE %I.%I %s;',
            trend_directory.staging_table_schema(),
            trend_directory.staging_table_name($1),
            (SELECT string_agg(trend_directory.add_column_sql_part(t), ',') FROM unnest($2) AS t)
          )
        ]
      );

- function:
    name: create_table_trends
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: trend_directory.trend_descr[]
    source: |-
      SELECT trend_directory.add_trends_to_trend_store_part(
        $1,
        array_agg(trend_directory.define_table_trend($1.id, t))
      ) FROM unnest($2) AS t

- function:
    name: add_generated_column_sql_part
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.generated_table_trend
    source: |-
      SELECT format(
        'ADD COLUMN %I %s GENERATED ALWAYS AS (%s) STORED',
        $1.name, $1.data_type, $1.expression
      );

- function:
    name: add_generated_trends_to_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: trend_directory.generated_table_trend[]
    source: |-
      SELECT public.action(
        $1,
        ARRAY[
          format(
            'ALTER TABLE %I.%I %s;',
            trend_directory.base_table_schema(),
            trend_directory.base_table_name($1),
            (SELECT string_agg(trend_directory.add_generated_column_sql_part(t), ',') FROM unnest($2) AS t)
          )
        ]
      );

- function:
    name: create_generated_table_trends
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: trend_directory.generated_trend_descr[]
    source: |-
      SELECT trend_directory.add_generated_trends_to_trend_store_part(
        $1,
        array_agg(trend_directory.define_generated_table_trend($1.id, t))
      ) FROM unnest($2) AS t

- function:
    name: missing_table_trends
    schema: trend_directory
    return_type: trend_directory.trend_descr
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - name: required
      data_type: trend_directory.trend_descr[]
    source: |-
      SELECT required
      FROM unnest($2) required
      LEFT JOIN trend_directory.table_trend ON table_trend.name = required.name AND table_trend.trend_store_part_id = $1.id
      WHERE table_trend.id IS NULL;

- function:
    name: missing_generated_table_trends
    schema: trend_directory
    return_type: trend_directory.generated_trend_descr
    returns_set: true
    language: sql
    volatility: stable
    arguments:
    - data_type: trend_directory.trend_store_part
    - name: required
      data_type: trend_directory.generated_trend_descr[]
    source: |-
      SELECT required
      FROM unnest($2) required
      LEFT JOIN trend_directory.generated_table_trend
      ON generated_table_trend.name = required.name AND generated_table_trend.trend_store_part_id = $1.id
      WHERE generated_table_trend.id IS NULL;

- function:
    name: missing_generated_table_trends
    schema: trend_directory
    return_type: trend_directory.generated_trend_descr
    returns_set: true
    language: sql
    volatility: stable
    arguments:
    - name: trend_store_part
      data_type: name
    - name: required
      data_type: trend_directory.generated_trend_descr[]
    source: |-
      SELECT trend_directory.missing_generated_table_trends(trend_store_part, $2)
      FROM trend_directory.trend_store_part WHERE name = $1

- function:
    name: assure_table_trends_exist
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: trend_store_id
    - data_type: text
      name: trend_store_part_name
    - data_type: trend_directory.trend_descr[]
    - data_type: trend_directory.generated_trend_descr[]
    source: |-
      DECLARE
        tsp trend_directory.trend_store_part;
        result text[];
      BEGIN
        SELECT * FROM trend_directory.get_or_create_trend_store_part($1, $2) INTO tsp;
 
        CREATE TEMP TABLE missing_trends(trend trend_directory.trend_descr);
        CREATE TEMP TABLE missing_generated_trends(trend trend_directory.generated_trend_descr);

        -- Normal trends
        INSERT INTO missing_trends SELECT trend_directory.missing_table_trends(tsp, $3);

        IF EXISTS (SELECT * FROM missing_trends LIMIT 1) THEN
          PERFORM trend_directory.create_table_trends(tsp, ARRAY(SELECT trend FROM missing_trends));
        END IF;

        -- Generated trends
        INSERT INTO missing_generated_trends SELECT trend_directory.missing_generated_table_trends(tsp, $4);

        IF EXISTS (SELECT * FROM missing_generated_trends LIMIT 1) THEN
          PERFORM trend_directory.create_generated_table_trends(tsp, missing_generated_trends);
        END IF;

        SELECT ARRAY(SELECT (mt).trend.name FROM missing_trends mt UNION SELECT (mt).trend.name FROM missing_generated_trends mt) INTO result;
        DROP TABLE missing_trends;
        DROP TABLE missing_generated_trends;

        RETURN result;
      END;

- function:
    name: add_trends
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        result text[];
        partresult text[];
      BEGIN
        FOR partresult IN
          SELECT trend_directory.assure_table_trends_exist(
            $1.id,
            name,
            trends,
            generated_trends
          )
          FROM unnest($2)
        LOOP
          SELECT result || partresult INTO result;
        END LOOP;
        RETURN result;
      END;

- function:
    name: add_trends
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part_descr
    source: |-
        SELECT trend_directory.assure_table_trends_exist(
          trend_store_part.trend_store_id,
          $1.name,
          $1.trends,
          $1.generated_trends
        )
        FROM trend_directory.trend_store_part
        WHERE name = $1.name;

- function:
    name: remove_table_trend
    schema: trend_directory
    return_type: trend_directory.table_trend
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend
      data_type: trend_directory.table_trend
    source: |-
      BEGIN
        EXECUTE FORMAT('ALTER TABLE trend.%I DROP COLUMN %I',
          trend_directory.trend_store_part_name_for_trend(trend), trend.name);
        EXECUTE FORMAT('ALTER TABLE trend.%I DROP COLUMN %I',
          trend_directory.trend_store_part_name_for_trend(trend)::text || '_staging', trend.name);
        DELETE FROM trend_directory.table_trend WHERE id = trend.id;
        RETURN t FROM trend_directory.table_trend t WHERE 0=1;
      END;

- function:
    name: trend_store_part_name_for_trend
    schema: trend_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: trend
      data_type: trend_directory.table_trend
    source: |-
      SELECT trend_store_part.name FROM trend_directory.table_trend LEFT JOIN trend_directory.trend_store_part
        ON table_trend.trend_store_part_id = trend_store_part.id
        WHERE table_trend.id = trend.id;

- function:
    name: trend_store_part_name_for_trend
    schema: trend_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: trend_id
      data_type: integer
    source: |-
      SELECT trend_store_part.name FROM trend_directory.table_trend LEFT JOIN trend_directory.trend_store_part
        ON table_trend.trend_store_part_id = trend_store_part.id
        WHERE table_trend.id = $1;

- function:
    name: get_trends_for_trend_store
    schema: trend_directory
    return_type: trend_directory.table_trend
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    source: |-
      SELECT table_trend
        FROM trend_directory.table_trend
        LEFT JOIN trend_directory.trend_store_part
        ON table_trend.trend_store_part_id = trend_store_part.id
        WHERE trend_store_part.trend_store_id = $1;

- function:
    name: get_trends_for_trend_store
    schema: trend_directory
    return_type: trend_directory.table_trend
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    source: |-
      SELECT trend_directory.get_trends_for_trend_store($1.id);

- function:
    name: get_trend_if_defined
    schema: trend_directory
    return_type: name
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend
      data_type: trend_directory.table_trend
    - name: trends
      data_type: trend_directory.trend_descr[]
    description: Return the trend, but only if it is a trend defined by trends
    source: |-
      SELECT t.name FROM trend_directory.table_trend t JOIN unnest($2) t2
        ON t.name = t2.name WHERE t.id = $1.id

- function:
    name: remove_trend_if_extraneous
    schema: trend_directory
    return_type: text
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend
      data_type: trend_directory.table_trend
    - name: trends
      data_type: trend_directory.trend_descr[]
    description: Remove the trend if it is not one that is described by trends
    source: |-
      DECLARE
        result text;
        defined_trend name;
      BEGIN
        SELECT trend_directory.get_trend_if_defined($1, $2) INTO defined_trend;
        IF defined_trend IS NULL THEN
          SELECT $1.name INTO result;
          PERFORM trend_directory.remove_table_trend($1);
        END IF;
        RETURN result;
      END;

- function:
    name: get_trends_for_trend_store_part
    schema: trend_directory
    return_type: trend_directory.table_trend
    returns_set: true
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: trend_store_part_id
      data_type: integer
    source: |-
      BEGIN
        RETURN QUERY EXECUTE FORMAT('SELECT * FROM trend_directory.table_trend WHERE table_trend.trend_store_part_id = %s;', $1);
      END;

- function:
    name: get_trends_for_trend_store_part
    schema: trend_directory
    return_type: trend_directory.table_trend
    returns_set: true
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    source: |-
      BEGIN
        RETURN QUERY EXECUTE FORMAT('SELECT trend_directory.get_trends_for_trend_store_part(%s);', $1.id);
      END;

- function:
    name: remove_extra_trends
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: integer
      name: trend_store_part_id
    - data_type: trend_directory.trend_descr[]
    source: |-
      DECLARE
        trend trend_directory.table_trend;
        removal_result text;
        result text[];
      BEGIN
        FOR trend IN SELECT * FROM trend_directory.get_trends_for_trend_store_part($1)
        LOOP
          SELECT trend_directory.remove_trend_if_extraneous(trend, $2) INTO removal_result;
          IF removal_result IS NOT NULL THEN
            SELECT result || removal_result INTO result;
          END IF;
        END LOOP;
        RETURN result;
      END;

- function:
    name: remove_extra_trends
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        result text[];
        partresult text[];
      BEGIN
        FOR partresult IN
          SELECT trend_directory.remove_extra_trends(
            trend_directory.get_trend_store_part($1.id, name), trends)
          FROM unnest($2)
        LOOP
          SELECT result || partresult INTO result;
        END LOOP;
        RETURN result;
      END;

- function:
    name: remove_extra_trends
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part_descr
    source: |-
        SELECT trend_directory.remove_extra_trends(
          id,
          $1.trends
        )
        FROM trend_directory.trend_store_part
        WHERE name = $1.name;

- function:
    name: change_table_trend_data_unsafe
    schema: trend_directory
    return_type: text
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: integer
      name: trend_id
    - name: data_type
      data_type: text
    - name: entity_aggregation
      data_type: text
    - name: time_aggregation
      data_type: text
    source: |-
      DECLARE
        result text;
        trend trend_directory.table_trend;
      BEGIN
        SELECT * FROM trend_directory.table_trend WHERE id = $1 INTO trend;
        IF trend.data_type <> $2 OR trend.entity_aggregation <> $3 OR trend.time_aggregation <> $4
        THEN
          UPDATE trend_directory.table_trend SET
            data_type = $2,
            entity_aggregation = $3,
            time_aggregation = $4
          WHERE id = $1;
          SELECT trend.name INTO result;
        END IF;

        IF trend.data_type <> $2
        THEN
          EXECUTE format('ALTER TABLE trend.%I ALTER %I TYPE %s USING CAST(%I AS %s)',
            trend_directory.trend_store_part_name_for_trend($1),
            trend.name,
            $2,
            trend.name,
            $2);
        END IF;

        RETURN result;
      END;

- function:
    name: data_type_order
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: immutable
    strict: true
    secdef: false
    arguments:
    - name: data_type
      data_type: text
    source: |-
      BEGIN
          CASE data_type
              WHEN 'smallint' THEN
                  RETURN 1;
              WHEN 'integer' THEN
                  RETURN 2;
              WHEN 'bigint' THEN
                  RETURN 3;
              WHEN 'real' THEN
                  RETURN 4;
              WHEN 'double precision' THEN
                  RETURN 5;
              WHEN 'numeric' THEN
                  RETURN 6;
              WHEN 'timestamp without time zone' THEN
                  RETURN 7;
              WHEN 'smallint[]' THEN
                  RETURN 8;
              WHEN 'integer[]' THEN
                  RETURN 9;
              WHEN 'numeric[]' THEN
                  RETURN 10;
              WHEN 'text[]' THEN
                  RETURN 11;
              WHEN 'text' THEN
                  RETURN 12;
              WHEN NULL THEN
                  RETURN NULL;
              ELSE
                  RAISE EXCEPTION 'Unsupported data type: %', data_type;
          END CASE;
      END;

- function:
    name: greatest_data_type
    schema: trend_directory
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - name: data_type_a
      data_type: text
    - name: data_type_b
      data_type: text
    source: |-
      SELECT
          CASE WHEN trend_directory.data_type_order($2) > trend_directory.data_type_order($1) THEN
              $2
          ELSE
              $1
          END;

- function:
    name: change_table_trend_data_safe
    schema: trend_directory
    return_type: text
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: integer
      name: trend_id
    - name: data_type
      data_type: text
    - name: entity_aggregation
      data_type: text
    - name: time_aggregation
      data_type: text
    source: |-
      DECLARE
        trend trend_directory.table_trend;
      BEGIN
        SELECT * FROM trend_directory.table_trend WHERE id = $1 INTO trend;
        RETURN trend_directory.change_table_trend_data_unsafe(
          $1,
          trend_directory.greatest_data_type($2, trend.data_type),
          $3,
          $4);
      END;

- function:
    name: change_trend_data_unsafe
    schema: trend_directory
    return_type: text
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend
      data_type: trend_directory.table_trend
    - name: trends
      data_type: trend_directory.trend_descr[]
    - name: partname
      data_type: text
    source: |-
      SELECT trend_directory.change_table_trend_data_unsafe($1.id, t.data_type, t.entity_aggregation, t.time_aggregation)
        FROM unnest($2) t
        WHERE t.name = $1.name AND trend_directory.trend_store_part_name_for_trend($1) = $3;

- function:
    name: change_trend_data_safe
    schema: trend_directory
    return_type: text
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend
      data_type: trend_directory.table_trend
    - name: trends
      data_type: trend_directory.trend_descr[]
    - name: partname
      data_type: text
    source: |-
      SELECT trend_directory.change_table_trend_data_safe($1.id, t.data_type, t.entity_aggregation, t.time_aggregation)
        FROM unnest($2) t
        WHERE t.name = $1.name AND trend_directory.trend_store_part_name_for_trend($1) = $3;

- function:
    name: change_all_trend_data
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        result text[];
        partresult text;
      BEGIN
        FOR partresult IN
          SELECT trend_directory.change_trend_data_unsafe(
            trend_directory.get_trends_for_trend_store($1), trends, name)
          FROM unnest($2)
        LOOP
          IF partresult IS NOT null THEN
            SELECT result || partresult INTO result;
          END IF;
        END LOOP;
        RETURN result;
      END;

- function:
    name: change_trend_data_upward
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        result text[];
        partresult text;
      BEGIN
        FOR partresult IN
          SELECT trend_directory.change_trend_data_safe(
            trend_directory.get_trends_for_trend_store($1), trends, name)
          FROM unnest($2)
        LOOP
          IF partresult IS NOT null THEN
            SELECT result || partresult INTO result;
          END IF;
        END LOOP;
        RETURN result;
      END;

- function:
    name: change_trend_data
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        result text[];
        partresult text;
      BEGIN
        FOR partresult IN
          SELECT trend_directory.change_trend_data_unsafe(
            trend_directory.get_trends_for_trend_store($1), trends, name)
          FROM unnest($2)
        LOOP
          IF partresult IS NOT null THEN
            SELECT result || partresult INTO result;
          END IF;
        END LOOP;
        RETURN result;
      END;

- function:
    name: trend_has_update
    schema: trend_directory
    return_type: boolean
    language: plpgsql
    arguments:
    - name: trend_id
      data_type: integer
    - name: trend_update
      data_type: trend_directory.trend_descr
    source: |-
      DECLARE
        trend trend_directory.table_trend;
      BEGIN
        SELECT * FROM trend_directory.table_trend WHERE id = $1 INTO trend;
        RETURN
          trend.data_type != $2.data_type
            OR
          trend.time_aggregation != $2.time_aggregation
            OR
          trend.entity_aggregation != $2.entity_aggregation;
      END;

- function:
    name: change_trend_data_upward
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part_descr
    source: |-
      SELECT array_agg(trend_directory.change_table_trend_data_safe(
        table_trend.id,
        t.data_type,
        t.entity_aggregation,
        t.time_aggregation
      ))
      FROM trend_directory.trend_store_part
        JOIN trend_directory.table_trend ON table_trend.trend_store_part_id = trend_store_part.id
        JOIN UNNEST($1.trends) AS t ON t.name = table_trend.name
        WHERE trend_store_part.name = $1.name AND trend_directory.trend_has_update(table_trend.id, t);

- function:
    name: change_trend_data
    schema: trend_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part_descr
    source: |-
      SELECT array_agg(trend_directory.change_table_trend_data_unsafe(
        table_trend.id,
        t.data_type,
        t.entity_aggregation,
        t.time_aggregation
      ))
      FROM trend_directory.trend_store_part
        JOIN trend_directory.table_trend ON table_trend.trend_store_part_id = trend_store_part.id
        JOIN UNNEST($1.trends) AS t ON t.name = table_trend.name
        WHERE trend_store_part.name = $1.name AND trend_directory.trend_has_update(table_trend.id, t);

- function:
    name: change_trendstore_strong
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        result text[];
        partresult text[];
      BEGIN
        SELECT trend_directory.add_trends($1, $2) INTO partresult;
        IF array_ndims(partresult) > 0
        THEN
          SELECT result || ARRAY['added trends:'] || partresult INTO result;
        ELSE
          SELECT result || ARRAY['no trends added'] INTO result;
        END IF;
        
        SELECT trend_directory.remove_extra_trends($1, $2) INTO partresult;
        IF array_ndims(partresult) > 0
        THEN
          SELECT result || ARRAY['removed trends:'] || partresult INTO result;
        ELSE
          SELECT result || ARRAY['no trends removed'] INTO result;
        END IF;

        SELECT trend_directory.change_all_trend_data($1, $2) INTO partresult;
        IF array_ndims(partresult) > 0
        THEN
          SELECT result || ARRAY['changed trends:'] || partresult INTO result;
        ELSE
          SELECT result || ARRAY['no trends changed'] INTO result;
        END IF;
        RETURN result;
      END;

- function:
    name: change_trendstore_weak
    schema: trend_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - name: parts
      data_type: trend_directory.trend_store_part_descr[]
    source: |-
      DECLARE
        result text[];
        partresult text[];
      BEGIN
        SELECT trend_directory.add_trends($1, $2) INTO partresult;
        IF array_ndims(partresult) > 0
        THEN
          SELECT result || ARRAY['added trends:'] || partresult INTO result;
        ELSE
          SELECT result || ARRAY['no trends added'] INTO result;
        END IF;
        
        SELECT trend_directory.remove_extra_trends($1, $2) INTO partresult;
        IF array_ndims(partresult) > 0
        THEN
          SELECT result || ARRAY['removed trends:'] || partresult INTO result;
        ELSE
          SELECT result || ARRAY['no trends removed'] INTO result;
        END IF;

        SELECT trend_directory.change_trend_data_upward($1, $2) INTO partresult;
        IF array_ndims(partresult) > 0
        THEN
          SELECT result || ARRAY['changed trends:'] || partresult INTO result;
        ELSE
          SELECT result || ARRAY['no trends changed'] INTO result;
        END IF;
        RETURN result;
      END;

- composite_type:
    name: change_trend_store_part_result
    schema: trend_directory
    columns:
    - name: added_trends
      data_type: text[]
      nullable: true
    - name: removed_trends
      data_type: text[]
      nullable: true
    - name: changed_trends
      data_type: text[]
      nullable: true

- function:
    name: change_trend_store_part_weak
    schema: trend_directory
    return_type: trend_directory.change_trend_store_part_result
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part_descr
    source: |-
      DECLARE
        result trend_directory.change_trend_store_part_result;
      BEGIN
        SELECT trend_directory.add_trends($1) INTO result.added_trends;

        SELECT trend_directory.remove_extra_trends($1) INTO result.removed_trends;

        SELECT trend_directory.change_trend_data_upward($1) INTO result.changed_trends;

        RETURN result;
      END;

- function:
    name: change_trend_store_part_strong
    schema: trend_directory
    return_type: trend_directory.change_trend_store_part_result
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part_descr
    source: |-
      DECLARE
        result trend_directory.change_trend_store_part_result;
      BEGIN
        SELECT trend_directory.add_trends($1) INTO result.added_trends;

        SELECT trend_directory.remove_extra_trends($1) INTO result.removed_trends;

        SELECT trend_directory.change_trend_data($1) INTO result.changed_trends;

        RETURN result;
      END;

- function:
    name: get_most_recent_timestamp
    schema: trend_directory
    return_type: timestamp with time zone
    language: plpgsql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - name: dest_granularity
      data_type: interval
    - name: ts
      data_type: timestamp with time zone
    source: |-
      DECLARE
          minute integer;
          rounded_minutes integer;
      BEGIN
          IF dest_granularity < '1 hour'::interval THEN
              minute := extract(minute FROM ts);
              rounded_minutes := minute - (minute % (dest_granularity / 60));

              return date_trunc('hour', ts) + (rounded_minutes || 'minutes')::INTERVAL;
          ELSIF dest_granularity = '1 hour'::interval THEN
              return date_trunc('hour', ts);
          ELSIF dest_granularity = '1 day'::interval THEN
              return date_trunc('day', ts);
          ELSIF dest_granularity = '1 week'::interval THEN
              return date_trunc('week', ts);
          ELSE
              RAISE EXCEPTION 'Invalid granularity: %', dest_granularity;
          END IF;
      END;

- function:
    name: is_integer
    schema: trend_directory
    return_type: bool
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: varchar
    source: |-
      SELECT $1 ~ '^[1-9][0-9]*$'

- function:
    name: get_most_recent_timestamp
    schema: trend_directory
    return_type: timestamp with time zone
    language: plpgsql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - name: dest_granularity
      data_type: varchar
    - name: ts
      data_type: timestamp with time zone
    source: |-
      DECLARE
          minute integer;
          rounded_minutes integer;
          seconds integer;
      BEGIN
          IF trend_directory.is_integer(dest_granularity) THEN
              seconds = cast(dest_granularity as integer);

              return trend_directory.get_most_recent_timestamp(seconds, ts);
          ELSIF dest_granularity = 'month' THEN
              return date_trunc('month', ts);
          ELSE
              RAISE EXCEPTION 'Invalid granularity: %', dest_granularity;
          END IF;

          return seconds;
      END;

- function:
    name: get_timestamp_for
    schema: trend_directory
    return_type: timestamp with time zone
    language: plpgsql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - name: granularity
      data_type: interval
    - name: ts
      data_type: timestamp with time zone
    source: |-
      DECLARE
          most_recent_timestamp timestamp with time zone;
      BEGIN
          most_recent_timestamp = trend_directory.get_most_recent_timestamp($1, $2);

          IF most_recent_timestamp != ts THEN
              IF granularity = 86400 THEN
                  return most_recent_timestamp + ('1 day')::INTERVAL;
              ELSE
                  return most_recent_timestamp + ($1 || ' seconds')::INTERVAL;
              END IF;
          ELSE
              return most_recent_timestamp;
          END IF;
      END;

- function:
    name: get_timestamp_for
    schema: trend_directory
    return_type: timestamp with time zone
    language: plpgsql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - name: granularity
      data_type: varchar
    - name: ts
      data_type: timestamp with time zone
    source: |-
      DECLARE
          most_recent_timestamp timestamp with time zone;
      BEGIN
          most_recent_timestamp = trend_directory.get_most_recent_timestamp($1, $2);

          IF most_recent_timestamp != ts THEN
              IF trend_directory.is_integer(granularity) THEN
                  IF granularity = '86400' THEN
                      return most_recent_timestamp + ('1 day')::INTERVAL;
                  ELSE
                      return most_recent_timestamp + ($1 || ' seconds')::INTERVAL;
                  END IF;
              ELSIF granularity = 'month' THEN
                  return most_recent_timestamp + '1 month'::INTERVAL;
              END IF;
          ELSE
              return most_recent_timestamp;
          END IF;
      END;

- function:
    name: get_table_trend
    schema: trend_directory
    return_type: trend_directory.table_trend
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: name
    source: |-
      SELECT table_trend
      FROM trend_directory.table_trend
      WHERE trend_store_part_id = $1.id AND name = $2;

- function:
    name: trend_store_part_has_trend_with_name
    schema: trend_directory
    return_type: bool
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: part
      data_type: trend_directory.trend_store_part
    - name: trend_name
      data_type: name
    source: |-
      SELECT exists(
          SELECT 1
          FROM trend_directory.table_trend
          WHERE trend_store_part_id = $1.id AND name = $2
      );

- function:
    name: column_exists
    schema: trend_directory
    return_type: bool
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: table_name
      data_type: name
    - name: column_name
      data_type: name
    source: |-
      SELECT EXISTS(
          SELECT 1
          FROM pg_attribute a
          JOIN pg_class c ON c.oid = a.attrelid
          JOIN pg_namespace n ON c.relnamespace = n.oid
          WHERE c.relname = table_name AND a.attname = column_name AND n.nspname = 'trend'
      );

- aggregate:
    name: max_data_type
    schema: trend_directory
    sfunc: trend_directory.greatest_data_type
    stype: text
    arguments:
    - data_type: text

- composite_type:
    name: upgrade_record
    schema: trend_directory
    columns:
    - name: timestamp
      data_type: timestamp with time zone
      nullable: false
    - name: number_of_rows
      data_type: integer
      nullable: false

- function:
    name: get_max_modified
    schema: trend_directory
    return_type: timestamp with time zone
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store
    - data_type: timestamp with time zone
    source: |-
      DECLARE
          max_modified timestamp with time zone;
      BEGIN
          EXECUTE format(
              'SELECT max(modified) FROM trend_directory.%I WHERE timestamp = $1',
              trend_directory.base_table_name($1)
          ) INTO max_modified USING $2;

          RETURN max_modified;
      END;


- function:
    name: update_modified
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_part_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    - name: modified
      data_type: timestamp with time zone
    source: |-
      INSERT INTO trend_directory.modified AS m (trend_store_part_id, timestamp, first, last)
      VALUES ($1, $2, $3, $3)
      ON CONFLICT ON CONSTRAINT modified_pkey DO UPDATE SET last = EXCLUDED.last;

- function:
    name: process_modified_log
    schema: trend_directory
    return_type: bigint
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: start_id
      data_type: bigint
    source: |-
      WITH process_log AS (
        SELECT
          max(id) AS max_id,
          trend_directory.update_modified(trend_store_part_id, timestamp, max(modified)) AS update
        FROM trend_directory.modified_log
        WHERE id > $1
        GROUP BY trend_store_part_id, timestamp
      ) SELECT coalesce(max(max_id), $1) FROM process_log;

- table:
    name: modified_log_processing_state
    schema: trend_directory
    columns:
    - name: name
      data_type: text
      nullable: false
    - name: last_processed_id
      data_type: bigint
      nullable: false
    - name: updated
      data_type: timestamp with time zone
      nullable: false
      default: now()
    primary_key:
      name: modified_log_processed_state_pkey
      columns:
      - name
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: process_modified_log
    schema: trend_directory
    return_type: bigint
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      WITH processed AS (
        SELECT trend_directory.process_modified_log(coalesce(max(last_processed_id), 0)) AS last_processed_id
        FROM trend_directory.modified_log_processing_state WHERE name = 'current'
      )
      INSERT INTO trend_directory.modified_log_processing_state(name, last_processed_id)
      SELECT 'current', processed.last_processed_id
      FROM processed
      ON CONFLICT (name) DO UPDATE SET last_processed_id = EXCLUDED.last_processed_id
      RETURNING last_processed_id;

- function:
    name: mark_modified
    schema: trend_directory
    return_type: void
    description: >
      Stores a record in the trend_directory.modified_log table.
    language: sql
    volatility: volatile
    arguments:
    - name: trend_store_part_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    - name: modified
      data_type: timestamp with time zone
    source: |-
      INSERT INTO trend_directory.modified_log(trend_store_part_id, timestamp, modified)
      VALUES ($1, $2, $3);

- function:
    name: mark_modified
    schema: trend_directory
    return_type: void
    description: >
      Stores a record in the trend_directory.modified_log table.
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      INSERT INTO trend_directory.modified_log(trend_store_part_id, timestamp, modified)
      VALUES ($1, $2, now());

- view:
    name: trend_store_part_stats_to_update
    schema: trend_directory
    query: |-
      SELECT tsps.trend_store_part_id,
          tsps.timestamp
        FROM trend_directory.trend_store_part_stats tsps
        JOIN trend_directory.modified m
        ON tsps.trend_store_part_id = m.trend_store_part_id
          AND tsps.timestamp = m.timestamp
        WHERE tsps.modified < m.last + interval '1 second';

- function:
    name: get_count
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: stable
    arguments:
    - name: trend_store_part_id
      data_type: integer
    - name: timestamp
      data_type: timestamptz
    source: |-
      DECLARE
        result integer;
      BEGIN
        EXECUTE FORMAT('SELECT COUNT(*)::integer FROM trend.%I WHERE timestamp = ''%s''',
          trend_directory.base_table_name_by_trend_store_part_id($1),
          $2) INTO result;
        RETURN result;
      END;

- function:
    name: recalculate_trend_store_part_stats
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    arguments:
    - data_type: integer
      name: trend_store_part_id
    - data_type: timestamptz
      name: timestamp
    source: |-
      UPDATE trend_directory.trend_store_part_stats
        SET modified = now(), count = trend_directory.get_count($1, $2)
        WHERE trend_store_part_id = $1
          AND timestamp = $2;

- function:
    name: update_trend_store_part_stats
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    source: |-
      SELECT trend_directory.recalculate_trend_store_part_stats(trend_store_part_id, timestamp)
        FROM trend_directory.trend_store_part_stats_to_update;

- function:
    name: create_missing_trend_store_part_stats
    schema: trend_directory
    return_type: void
    language: sql
    volatility: volatile
    description: |-
      Create trend_store_part_stat where it does not exist yet.
    source: |-
      INSERT INTO trend_directory.trend_store_part_stats (trend_store_part_id, timestamp, modified, count)
        SELECT m.trend_store_part_id, m.timestamp, '2000-01-01 00:00:00+02', 0
          FROM trend_directory.modified m
            LEFT JOIN trend_directory.trend_store_part_stats s
            ON s.trend_store_part_id = m.trend_store_part_id AND s.timestamp = m.timestamp
            WHERE s IS NULL;

- composite_type:
    name: transfer_result
    schema: trend_directory
    columns:
    - name: row_count
      data_type: integer
      nullable: false
    - name: max_modified
      data_type: timestamp with time zone
      nullable: false

- function:
    name: clear_trend_store_part_sql
    schema: trend_directory
    return_type: text
    description: >
      Return the query to remove all records of the specified timestamp from the
      trend_store_part.
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_part_id
      data_type: integer
    source: |-
      SELECT format('DELETE FROM trend.%I WHERE timestamp = $1', ttsp.name)
      FROM trend_directory.trend_store_part ttsp WHERE id = $1;

- function:
    name: clear_trend_store_part
    schema: trend_directory
    return_type: integer
    description: >
      Removes all records of the specified timestamp from the
      trend_store_part and returns the removed record count.
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: trend_store_part_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      DECLARE
          row_count integer;
      BEGIN
          EXECUTE trend_directory.clear_trend_store_part_sql($1) USING $2;

          GET DIAGNOSTICS row_count = ROW_COUNT;

          RETURN row_count;
      END;

- function:
    name: view_materialization_transfer
    schema: trend_directory
    return_type: integer
    description: Transfer all records of the specified timestamp from the view to the target trend store of the materialization.
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: materialization_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      DECLARE
          mat trend_directory.view_materialization;
          columns_part text;
          row_count integer;
          job_id bigint;
      BEGIN
          SELECT * FROM trend_directory.view_materialization WHERE view_materialization.materialization_id = $1 INTO mat;
          SELECT logging.start_job(format('{"view_materialization": "%s", "timestamp": "%s"}', m::text, $2::text)::jsonb) INTO job_id
          FROM trend_directory.materialization m WHERE id = $1;

          SELECT trend_directory.view_materialization_columns_part($1) INTO columns_part;

          EXECUTE format(
              'INSERT INTO trend.%I (entity_id, timestamp, created, job_id, %s) SELECT entity_id, timestamp, now(), %s, %s FROM %s WHERE timestamp = $1',
              (trend_directory.dst_trend_store_part($1)).name,
              columns_part,
              job_id,
              columns_part,
              mat.src_view::name
          ) USING timestamp;

          GET DIAGNOSTICS row_count = ROW_COUNT;

          PERFORM logging.end_job(job_id);

          RETURN row_count;
      END;

- function:
    name: function_materialization_transfer
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: materialization_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      DECLARE
          mat trend_directory.function_materialization;
          columns_part text;
          row_count integer;
          job_id bigint;
      BEGIN
          SELECT * FROM trend_directory.function_materialization fm WHERE fm.materialization_id = $1 into mat;
          IF mat IS NULL
            THEN RETURN NULL;
          END IF;
          SELECT logging.start_job(format('{"function_materialization": "%s", "timestamp": "%s"}', m::text, $2::text)::jsonb) INTO job_id
          FROM trend_directory.materialization m WHERE id = $1;

          SELECT trend_directory.function_materialization_columns_part($1) INTO columns_part;

          EXECUTE format(
              'INSERT INTO trend.%I (entity_id, timestamp, created, job_id, %s) SELECT entity_id, timestamp, now(), %s, %s FROM %s($1)',
              (trend_directory.dst_trend_store_part($1)).name,
              columns_part,
              job_id,
              columns_part,
              mat.src_function::regproc
          ) USING timestamp;

          GET DIAGNOSTICS row_count = ROW_COUNT;

          PERFORM logging.end_job(job_id);

          RETURN row_count;
      END;

- function:
    name: transfer
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: materialization_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      DECLARE
        row_count integer;
      BEGIN
        SELECT trend_directory.function_materialization_transfer($1, $2) INTO row_count;

        IF row_count IS NULL THEN
          SELECT trend_directory.view_materialization_transfer($1, $2) INTO row_count;
        END IF;

        RETURN row_count;
      END;

- function:
    name: materialize
    schema: trend_directory
    return_type: trend_directory.transfer_result
    language: plpgsql
    description: >
      Materialize the data produced by the referenced view of the
      materialization by clearing the timestamp in the target
      trend_store_part and inserting the data resulting from the view
      into it.
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: materialization_id
      data_type: integer
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      DECLARE
          mat trend_directory.materialization;
          start timestamp with time zone;
          duration interval;
          columns_part text;
          result trend_directory.transfer_result;
      BEGIN
          SELECT * FROM trend_directory.materialization WHERE id = $1 INTO mat;

          start = clock_timestamp();

          -- Remove all records in the target table for the timestamp to materialize
          PERFORM trend_directory.clear_trend_store_part(
              mat.dst_trend_store_part_id, $2
          );

          result.row_count = trend_directory.transfer($1, $2);

          -- Update the state of this materialization
          UPDATE trend_directory.materialization_state vms
          SET processed_fingerprint = vms.source_fingerprint
          WHERE vms.materialization_id = $1 AND vms.timestamp = $2;

          -- Log the change in the target trend store part
          PERFORM trend_directory.mark_modified(mat.dst_trend_store_part_id, $2, now());

          duration = clock_timestamp() - start;

          UPDATE trend_directory.materialization_metrics
          SET execution_count = execution_count + 1, total_duration = total_duration + duration
          WHERE materialization_metrics.materialization_id = $1;

          RETURN result;
      END;

- function:
    name: materialize
    schema: trend_directory
    return_type: trend_directory.transfer_result
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.materialization
    - name: timestamp
      data_type: timestamp with time zone
    source: |-
      SELECT trend_directory.materialize($1.id, $2);

- function:
    name: show_trends
    schema: trend_directory
    return_type: trend_directory.trend_descr
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: trend_store_part_id
      data_type: integer
    source: |-
      SELECT trend_directory.show_trends(trend_store_part)
      FROM trend_directory.trend_store_part
      WHERE id = $1;

- function:
    name: clear
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.trend_store_part
    - data_type: timestamp with time zone
    source: |-
      DECLARE
          row_count integer;
      BEGIN
          EXECUTE format(
              'DELETE FROM %I.%I WHERE timestamp = $1',
              trend_directory.base_table_schema(),
              trend_directory.base_table_name($1)
          ) USING $2;

          GET DIAGNOSTICS row_count = ROW_COUNT;

          RETURN row_count;
      END;

- function:
    name: add_new_state
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      DECLARE
          count integer;
      BEGIN
          INSERT INTO trend_directory.state(materialization_id, timestamp, max_modified, source_states)
          SELECT materialization_id, timestamp, max_modified, source_states
          FROM trend_directory.new_materializables;

          GET DIAGNOSTICS count = ROW_COUNT;

          RETURN count;
      END;

- function:
    name: update_modified_state
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      DECLARE
          count integer;
      BEGIN
          UPDATE trend_directory.state
          SET
              max_modified = mzb.max_modified,
              source_states = mzb.source_states
          FROM trend_directory.modified_materializables mzb
          WHERE
              state.materialization_id = mzb.materialization_id AND
              state.timestamp = mzb.timestamp;

          GET DIAGNOSTICS count = ROW_COUNT;

          RETURN count;
      END;

- function:
    name: delete_obsolete_state
    schema: trend_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      DECLARE
          count integer;
      BEGIN
          DELETE FROM trend_directory.state
          USING trend_directory.obsolete_state
          WHERE
              state.materialization_id = obsolete_state.materialization_id AND
              state.timestamp = obsolete_state.timestamp;

          GET DIAGNOSTICS count = ROW_COUNT;

          RETURN count;
      END;

- function:
    name: update_state
    schema: trend_directory
    return_type: text
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT 'added: ' || trend_directory.add_new_state() || ', updated: ' || trend_directory.update_modified_state() || ', deleted: ' || trend_directory.delete_obsolete_state();

- function:
    name: dst_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.materialization
    source: |-
      SELECT * FROM trend_directory.trend_store_part WHERE id = $1.dst_trend_store_part_id;

- function:
    name: dst_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: integer
      name: materialization_id
    source: |-
      SELECT tsp.* FROM trend_directory.trend_store_part tsp
        JOIN trend_directory.materialization m ON tsp.id = m.dst_trend_store_part_id
        WHERE m.id = $1;

- function:
    name: dst_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.view_materialization
    source: |-
      SELECT p.*
      FROM trend_directory.trend_store_part p
      JOIN trend_directory.materialization m ON m.dst_trend_store_part_id = p.id
      WHERE m.id = $1.materialization_id;

- function:
    name: dst_trend_store_part
    schema: trend_directory
    return_type: trend_directory.trend_store_part
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trend_directory.function_materialization
    source: |-
      SELECT p.*
      FROM trend_directory.trend_store_part p
      JOIN trend_directory.materialization m ON m.dst_trend_store_part_id = p.id
      WHERE m.id = $1.materialization_id;

- function:
    name: columns_part
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    description: |-
      Return the comma separated, quoted list of column names to be used in queries
    arguments:
    - data_type: integer
      name: trend_store_part_id
    source: |-
      WITH columns AS (
        SELECT t.name
        FROM trend_directory.trend_store_part ttsp
        JOIN trend_directory.table_trend t ON t.trend_store_part_id = ttsp.id
        WHERE ttsp.id = $1
      )
      SELECT
        array_to_string(array_agg(quote_ident(name)), ', ')
      FROM columns;

- function:
    name: view_materialization_columns_part
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    description: |-
      Return the comma separated, quoted list of column names to be used in queries
    arguments:
    - data_type: integer
      name: materialization_id
    source: |-
      SELECT trend_directory.columns_part(m.dst_trend_store_part_id)
        FROM trend_directory.materialization m
        WHERE id = $1;

- function:
    name: function_materialization_columns_part
    schema: trend_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    description: |-
      Return the comma separated, quoted list of column names to be used in queries
    arguments:
    - data_type: integer
      name: materialization_id
    source: |-
      SELECT trend_directory.columns_part(m.dst_trend_store_part_id)
      FROM trend_directory.materialization m
      WHERE id = $1;

- cast:
    source:
      schema: trend_directory
      name: trend_store_part
    target:
      schema: pg_catalog
      name: text
    function:
      schema: trend_directory
      name: to_char
    implicit: true

- cast:
    source:
      schema: trend_directory
      name: trend_store_part
    target:
      schema: pg_catalog
      name: name
    function:
      schema: trend_directory
      name: base_table_name
    implicit: true

- cast:
    source:
      schema: trend_directory
      name: trend_view_part
    target:
      schema: pg_catalog
      name: text
    function:
      schema: trend_directory
      name: to_char
    implicit: true

- cast:
    source:
      schema: trend_directory
      name: trend_view_part
    target:
      schema: pg_catalog
      name: name
    function:
      schema: trend_directory
      name: view_name
    implicit: true

- cast:
    source:
      schema: trend_directory
      name: materialization
    target:
      schema: pg_catalog
      name: text
    function:
      schema: trend_directory
      name: to_char
    implicit: false

- function:
    name: update_modified_column
    schema: trend_directory
    return_type: trigger
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      BEGIN
          NEW.modified = NOW();

          RETURN NEW;
      END;

- function:
    name: create_stats_on_creation
    schema: trend_directory
    return_type: trigger
    language: plpgsql
    volatility: volatile
    arguments: []
    source: |-
      BEGIN
        INSERT INTO trend_directory.trend_store_part_stats (trend_store_part_id, timestamp, modified, count)
          VALUES (NEW.trend_store_part_id, NEW.timestamp, '2000-01-01 00:00:00+02', 1);
        RETURN NEW;
      END;

- trigger:
    table:
      schema: trend_directory
      name: modified
    name: create_stats_on_creation
    function:
      schema: trend_directory
      name: create_stats_on_creation
    when: after
    events:
    - insert
    affecteach: row

#######################
#######################
##                   ##
## Attribute Storage ##
##                   ##
#######################
#######################

- table:
    name: attribute_store
    schema: attribute_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: data_source_id
      data_type: integer
      nullable: false
    - name: entity_type_id
      data_type: integer
      nullable: false
    primary_key:
      name: attribute_store_pkey
      columns:
      - id
    foreign_keys:
    - name: attribute_attribute_store_entity_type_id_fkey
      columns:
      - entity_type_id
      references:
        table:
          name: entity_type
          schema: directory
        columns:
        - id
      on_delete: cascade
    - name: attribute_attribute_store_data_source_id_fkey
      columns:
      - data_source_id
      references:
        table:
          name: data_source
          schema: directory
        columns:
        - id
    indexes:
    - name: attribute_store_uniqueness
      unique: true
      definition: btree (data_source_id, entity_type_id)
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: get_attribute_store
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: data_source_id
      data_type: integer
    - name: entity_type_id
      data_type: integer
    source: |-
      SELECT attribute_store
      FROM attribute_directory.attribute_store
      WHERE data_source_id = $1 AND entity_type_id = $2;

- function:
    name: get_attribute_store
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source
      data_type: text
    - name: entity_type
      data_type: text
    source: |-
      SELECT attribute_store
      FROM attribute_directory.attribute_store
      LEFT JOIN directory.data_source
        ON data_source_id = data_source.id
      LEFT JOIN directory.entity_type
        ON entity_type_id = entity_type.id
      WHERE data_source.name = $1 AND lower(entity_type.name) = lower($2);

- function:
    name: get_attribute_store
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: stable
    arguments:
    - name: attribute_store_id
      data_type: integer
    source: |
      SELECT attribute_store
      FROM attribute_directory.attribute_store
      WHERE id = $1
    
- table:
    name: sampled_view_materialization
    schema: attribute_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: attribute_store_id
      data_type: integer
      nullable: false
    - name: src_view
      data_type: text
      nullable: false
    foreign_keys:
    - name: sampled_view_materialization_attribute_store_id_fkey
      columns:
      - attribute_store_id
      references:
        table:
          name: attribute_store
          schema: attribute_directory
        columns:
        - id
      on_delete: cascade

- composite_type:
    name: attribute_descr
    schema: attribute_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false
    - name: description
      data_type: text
      nullable: false

- table:
    name: attribute
    schema: attribute_directory
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: attribute_store_id
      data_type: integer
      nullable: false
    - name: description
      data_type: text
      nullable: true
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: text
      nullable: false
    - name: extra_data
      data_type: jsonb
      nullable: false
      default: "'{}'"
    primary_key:
      name: attribute_pkey
      columns:
      - id
    foreign_keys:
    - name: attribute_attribute_attribute_store_id_fkey
      columns:
      - attribute_store_id
      references:
        table:
          name: attribute_store
          schema: attribute_directory
        columns:
        - id
      on_delete: cascade
    indexes:
    - name: attribute_uniqueness
      unique: true
      definition: btree (attribute_store_id, name)
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: attribute_tag_link
    schema: attribute_directory
    columns:
    - name: attribute_id
      data_type: integer
      nullable: false
    - name: tag_id
      data_type: integer
      nullable: false
    primary_key:
      name: attribute_tag_link_pkey
      columns:
      - attribute_id
      - tag_id
    foreign_keys:
    - name: attribute_tag_link_tag_id_fkey
      columns:
      - tag_id
      references:
        table:
          name: tag
          schema: directory
        columns:
        - id
      on_delete: cascade
    - name: attribute_tag_link_attribute_id_fkey
      columns:
      - attribute_id
      references:
        table:
          name: attribute
          schema: attribute_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: attribute_store_modified
    schema: attribute_directory
    columns:
    - name: attribute_store_id
      data_type: integer
      nullable: false
    - name: modified
      data_type: timestamp with time zone
      nullable: false
    primary_key:
      name: attribute_store_modified_pkey
      columns:
      - attribute_store_id
    foreign_keys:
    - name: attribute_store_modified_attribute_store_id_fkey
      columns:
      - attribute_store_id
      references:
        table:
          name: attribute_store
          schema: attribute_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: attribute_store_curr_materialized
    schema: attribute_directory
    columns:
    - name: attribute_store_id
      data_type: integer
      nullable: false
    - name: materialized
      data_type: timestamp with time zone
      nullable: false
    primary_key:
      name: attribute_store_curr_materialized_pkey
      columns:
      - attribute_store_id
    foreign_keys:
    - name: attribute_store_curr_materialized_attribute_store_id_fkey
      columns:
      - attribute_store_id
      references:
        table:
          name: attribute_store
          schema: attribute_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: attribute_store_compacted
    schema: attribute_directory
    columns:
    - name: attribute_store_id
      data_type: integer
      nullable: false
    - name: compacted
      data_type: integer
      nullable: false
    primary_key:
      name: attribute_store_compacted_pkey
      columns:
      - attribute_store_id
    foreign_keys:
    - name: attribute_store_compacted_attribute_store_id_fkey
      columns:
      - attribute_store_id
      references:
        table:
          name: attribute_store
          schema: attribute_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- composite_type:
    name: attribute_info
    schema: attribute_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: varchar
      nullable: false

- function:
    name: to_char
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT data_source.name || '_' || entity_type.name
        FROM directory.data_source, directory.entity_type
        WHERE data_source.id = $1.data_source_id AND entity_type.id = $1.entity_type_id;

- function:
    name: attribute_store_to_char
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: integer
      name: attribute_store_id
    source: |-
      SELECT data_source.name || '_' || entity_type.name
        FROM attribute_directory.attribute_store
          JOIN directory.data_source ON data_source.id = attribute_store.data_source_id
          JOIN directory.entity_type ON entity_type.id = attribute_store.entity_type_id
        WHERE attribute_store.id = $1;

- function:
    name: attribute_name
    schema: attribute_directory
    return_type: text
    language: plpgsql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    source: |-
      DECLARE
        attribute attribute_directory.attribute_store;
      BEGIN
        SELECT * FROM attribute_directory.attribute_store WHERE id = $1 INTO attribute;
        RETURN attribute_directory.to_char(attribute);
      END;

- function:
    name: to_table_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_char($1))::name;

- function:
    name: at_function_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_at')::name;

- function:
    name: staging_new_view_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_new')::name;

- function:
    name: staging_modified_view_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_modified')::name;

- function:
    name: changes_view_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_changes')::name;

- function:
    name: run_length_view_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_run_length')::name;

- function:
    name: compacted_view_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_compacted')::name;

- function:
    name: curr_ptr_view_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_curr_selection')::name;

- function:
    name: curr_view_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT attribute_directory.to_table_name($1);

- function:
    name: curr_ptr_table_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_curr_ptr')::name;

- function:
    name: hash_query_part
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute
    source: |-
      SELECT CASE
        WHEN $1.data_type LIKE '%[]'
        THEN format('array_to_text(%I)', $1.name)
        ELSE format('%I::text', $1.name)
      END;

- function:
    name: hash_query
    schema: attribute_directory
    return_type: text
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      BEGIN
        IF action_count(format('SELECT 1 FROM attribute_directory.attribute WHERE attribute_store_id = %s', $1.id)) = 0
          THEN RETURN '''Q''';
        ELSE 
          RETURN 'md5(' ||
            array_to_string(array_agg(format('(CASE WHEN %I IS NULL THEN '''' ELSE %s END)', name, attribute_directory.hash_query_part(a))), ' || ') ||
            ')' FROM attribute_directory.attribute a WHERE attribute_store_id = $1.id;
        END IF;
      END;
 

- function:
    name: changes_view_query
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format('SELECT entity_id, timestamp, COALESCE(hash <> lag(hash) OVER w, true) AS change
      FROM attribute_history.%I WINDOW w AS (PARTITION BY entity_id ORDER BY timestamp asc)', attribute_directory.to_table_name($1));

- function:
    name: create_changes_view_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format('CREATE VIEW attribute_history.%I AS %s',
              attribute_directory.changes_view_name($1),
              attribute_directory.changes_view_query($1)
          ),
          format('ALTER TABLE attribute_history.%I OWNER TO minerva_writer',
              attribute_directory.changes_view_name($1)
          )
      ];

- function:
    name: create_changes_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_changes_view_sql($1)
      );

- function:
    name: run_length_view_query
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format('SELECT
          min(id) AS id,
          public.first(entity_id) AS entity_id,
          min(timestamp) AS "start",
          max(timestamp) AS "end",
          min(first_appearance) AS first_appearance,
          max(modified) AS modified,
          count(*) AS run_length
      FROM
      (
          SELECT id, entity_id, timestamp, first_appearance, modified, sum(change) OVER w2 AS run
          FROM
          (
              SELECT id, entity_id, timestamp, first_appearance, modified, CASE WHEN hash <> lag(hash) OVER w THEN 1 ELSE 0 END AS change
              FROM attribute_history.%I
              WINDOW w AS (PARTITION BY entity_id ORDER BY timestamp asc)
          ) t
          WINDOW w2 AS (PARTITION BY entity_id ORDER BY timestamp ASC)
      ) runs
      GROUP BY entity_id, run;', attribute_directory.to_table_name($1));

- function:
    name: create_run_length_view_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE VIEW attribute_history.%I AS %s',
              attribute_directory.run_length_view_name($1),
              attribute_directory.run_length_view_query($1)
          ),
          format(
              'ALTER TABLE attribute_history.%I OWNER TO minerva_writer',
              attribute_directory.run_length_view_name($1)
          )
      ];

- function:
    name: create_run_length_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    description: 'Create a view on an attribute_store''s history table that lists
      the runs of

      duplicate attribute data records by their entity ID and start-end. This can

      be used as a source for compacting actions.'
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_run_length_view_sql($1)
      );

- function:
    name: drop_run_length_view_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP VIEW attribute_history.%I',
          attribute_directory.run_length_view_name($1)
      );

- function:
    name: drop_run_length_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    description: 'Drop the run-length view of the attribute store.'
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_run_length_view_sql($1)
      );

- function:
    name: drop_changes_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          format('DROP VIEW attribute_history.%I', attribute_directory.changes_view_name($1))
      );

- function:
    name: curr_view_query
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'SELECT h.* FROM attribute_history.%I h JOIN attribute_history.%I c ON h.id = c.id',
          attribute_directory.to_table_name($1),
          attribute_directory.curr_ptr_table_name($1)
      );

- function:
    name: create_curr_view_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE VIEW attribute.%I AS %s',
              attribute_directory.curr_view_name($1),
              attribute_directory.curr_view_query($1)
          ),
          format(
              'ALTER TABLE attribute.%I OWNER TO minerva_writer',
              attribute_directory.curr_view_name($1)
          )
      ];

- function:
    name: create_curr_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_curr_view_sql($1)
      );

- function:
    name: drop_curr_view_sql
    schema: attribute_directory
    return_type: varchar
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format('DROP VIEW attribute.%I CASCADE', attribute_directory.to_table_name($1));

- function:
    name: drop_curr_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_curr_view_sql($1)
      );

- function:
    name: create_curr_ptr_table_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format('CREATE TABLE attribute_history.%I (
              id integer,
              PRIMARY KEY (id))',
              attribute_directory.curr_ptr_table_name($1)
          ),
          format(
              'CREATE INDEX ON attribute_history.%I (id)',
              attribute_directory.curr_ptr_table_name($1)
          ),
          format(
              'ALTER TABLE attribute_history.%I OWNER TO minerva_writer',
              attribute_directory.curr_ptr_table_name($1)
          )
      ];

- function:
    name: create_curr_ptr_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_curr_ptr_table_sql($1)
      );

- function:
    name: drop_curr_ptr_table_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP TABLE attribute_history.%I',
          attribute_directory.curr_ptr_table_name($1)
      );

- function:
    name: drop_curr_ptr_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_curr_ptr_table_sql($1)
      );

- function:
    name: create_curr_ptr_view_sql
    schema: attribute_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      DECLARE
          table_name name := attribute_directory.to_table_name($1);
          view_name name := attribute_directory.curr_ptr_view_name($1);
          view_sql text;
      BEGIN
          view_sql = format(
              'SELECT DISTINCT ON (entity_id) '
              'a.id '
              'FROM attribute_history.%I a '
              'ORDER BY entity_id, timestamp DESC',
              table_name
          );

          RETURN ARRAY[
              format('CREATE VIEW attribute_history.%I AS %s', view_name, view_sql),
              format(
                  'ALTER TABLE attribute_history.%I '
                  'OWNER TO minerva_writer',
                  view_name
              )
          ];
      END;

- function:
    name: create_curr_ptr_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_curr_ptr_view_sql($1)
      );

- function:
    name: drop_curr_ptr_view_sql
    schema: attribute_directory
    return_type: varchar
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format('DROP VIEW attribute_history.%I', attribute_directory.curr_ptr_view_name($1));

- function:
    name: drop_curr_ptr_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_curr_ptr_view_sql($1)
      );

- function:
    name: base_columns
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT ARRAY[
          'entity_id integer NOT NULL',
          '"timestamp" timestamp with time zone NOT NULL',
          '"end" timestamp with time zone DEFAULT NULL'
      ];

- function:
    name: column_specs
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT attribute_directory.base_columns() || array_agg(format('%I %s', name, data_type))
      FROM attribute_directory.attribute
      WHERE attribute_store_id = $1.id;

- function:
    name: create_base_table_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE TABLE attribute_base.%I (%s)',
              attribute_directory.to_table_name($1),
              array_to_string(attribute_directory.column_specs($1), ',')
          ),
          format(
              'ALTER TABLE attribute_base.%I OWNER TO minerva_writer',
              attribute_directory.to_table_name($1)
          ),
          format(
              'SELECT create_distributed_table(''attribute_base.%I'', ''entity_id'')',
              attribute_directory.to_table_name($1)
          )
      ]

- function:
    name: create_base_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action($1, attribute_directory.create_base_table_sql($1));

- function:
    name: drop_base_table_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP TABLE attribute_base.%I',
          attribute_directory.to_table_name($1)
      );

- function:
    name: drop_base_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action($1, attribute_directory.drop_base_table_sql($1));

- function:
    name: add_first_appearance_to_attribute_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      DECLARE
          table_name name;
      BEGIN
          table_name = attribute_directory.to_table_name($1);

          EXECUTE format('ALTER TABLE attribute_base.%I ADD COLUMN
              first_appearance timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP', table_name);

          EXECUTE format('UPDATE attribute_history.%I SET first_appearance = modified', table_name);

          EXECUTE format('CREATE INDEX ON attribute_history.%I (first_appearance)', table_name);

          RETURN $1;
      END;

- function:
    name: create_history_table_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE TABLE attribute_history.%I (
              id serial,
              first_appearance timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
              modified timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
              hash character varying GENERATED ALWAYS AS (%s) STORED,
              %s,
              PRIMARY KEY (id, entity_id)
              )',
              attribute_directory.to_table_name($1),
              attribute_directory.hash_query($1),
              array_to_string(attribute_directory.column_specs($1), ',')
          ),
          format(
              'CREATE INDEX ON attribute_history.%I (id)',
              attribute_directory.to_table_name($1)
          ),
          format(
              'CREATE INDEX ON attribute_history.%I (first_appearance)',
              attribute_directory.to_table_name($1)
          ),
          format(
              'CREATE INDEX ON attribute_history.%I (modified)',
              attribute_directory.to_table_name($1)
          ),
          format(
              'ALTER TABLE attribute_history.%I OWNER TO minerva_writer',
              attribute_directory.to_table_name($1)
          ),
          format(
              'SELECT create_distributed_table(''attribute_history.%I'', ''entity_id'')',
              attribute_directory.to_table_name($1)
          )
      ];

- function:
    name: create_history_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action($1, attribute_directory.create_history_table_sql($1));

- function:
    name: drop_history_table_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP TABLE attribute_history.%I',
          attribute_directory.to_table_name($1)
      );

- function:
    name: drop_history_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action($1, attribute_directory.drop_history_table_sql($1));

- function:
    name: create_staging_table_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE UNLOGGED TABLE attribute_staging.%I (%s)',
              attribute_directory.to_table_name($1),
              array_to_string(attribute_directory.column_specs($1), ',')
          ),
          format(
              'CREATE INDEX ON attribute_staging.%I USING btree (entity_id, timestamp)',
              attribute_directory.to_table_name($1)
          ),
          format(
              'ALTER TABLE attribute_staging.%I OWNER TO minerva_writer',
              attribute_directory.to_table_name($1)
          ),
          format(
              'SELECT create_distributed_table(''attribute_staging.%I'', ''entity_id'')',
              attribute_directory.to_table_name($1)
          )
      ];

- function:
    name: create_staging_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_staging_table_sql($1)
      );

- function:
    name: drop_staging_table_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP TABLE attribute_staging.%I',
          attribute_directory.to_table_name($1)
      );

- function:
    name: drop_staging_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_staging_table_sql($1)
      );

- function:
    name: create_staging_new_view_sql
    schema: attribute_directory
    return_type: text[]
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      DECLARE
          table_name name;
          view_name name;
          column_expressions text[];
          columns_part character varying;
      BEGIN
          table_name = attribute_directory.to_table_name($1);
          view_name = attribute_directory.staging_new_view_name($1);

          SELECT
              array_agg(format('public.last(s.%I) AS %I', name, name)) INTO column_expressions
          FROM
              public.column_names('attribute_staging', table_name) name
          WHERE name NOT in ('entity_id', 'timestamp');

          SELECT array_to_string(
              ARRAY['s.entity_id', 's.timestamp'] || column_expressions,
              ', ')
          INTO columns_part;

          RETURN ARRAY[
              format('CREATE VIEW attribute_staging.%I
      AS SELECT %s FROM attribute_staging.%I s
      LEFT JOIN attribute_history.%I a
          ON a.entity_id = s.entity_id
          AND a.timestamp = s.timestamp
      WHERE a.entity_id IS NULL
      GROUP BY s.entity_id, s.timestamp', view_name, columns_part, table_name, table_name),
              format('ALTER TABLE attribute_staging.%I OWNER TO minerva_writer', view_name)
          ];
      END;

- function:
    name: create_staging_new_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_staging_new_view_sql($1)
      );

- function:
    name: drop_staging_new_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      BEGIN
          EXECUTE format('DROP VIEW attribute_staging.%I', attribute_directory.to_table_name($1) || '_new');

          RETURN $1;
      END;

- function:
    name: create_staging_modified_view_sql
    schema: attribute_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      DECLARE
          table_name name;
          view_name name;
      BEGIN
          table_name = attribute_directory.to_table_name($1);
          view_name = attribute_directory.staging_modified_view_name($1);

          RETURN ARRAY[
              format('CREATE VIEW attribute_staging.%I
      AS SELECT s.* FROM attribute_staging.%I s
      JOIN attribute_history.%I a ON a.entity_id = s.entity_id AND a.timestamp = s.timestamp', view_name, table_name, table_name),
              format('ALTER TABLE attribute_staging.%I
              OWNER TO minerva_writer', view_name)
          ];
      END;

- function:
    name: create_staging_modified_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_staging_modified_view_sql($1)
      );

- function:
    name: drop_staging_modified_view_sql
    schema: attribute_directory
    return_type: varchar
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format('DROP VIEW attribute_staging.%I', attribute_directory.staging_modified_view_name($1));

- function:
    name: drop_staging_modified_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_staging_modified_view_sql($1)
      );

- function:
    name: update_curr_materialized
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_curr_materialized
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    - name: materialized
      data_type: timestamp with time zone
    source: |-
      UPDATE attribute_directory.attribute_store_curr_materialized
      SET materialized = greatest(materialized, $2)
      WHERE attribute_store_id = $1
      RETURNING attribute_store_curr_materialized;

- function:
    name: store_curr_materialized
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_curr_materialized
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    - name: materialized
      data_type: timestamp with time zone
    source: |-
      INSERT INTO attribute_directory.attribute_store_curr_materialized (attribute_store_id, materialized)
      VALUES ($1, $2)
      RETURNING attribute_store_curr_materialized;

- function:
    name: mark_curr_materialized
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_curr_materialized
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    - name: materialized
      data_type: timestamp with time zone
    source: |-
      SELECT COALESCE(attribute_directory.update_curr_materialized($1, $2), attribute_directory.store_curr_materialized($1, $2));

- function:
    name: mark_curr_materialized
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_curr_materialized
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    source: |-
      SELECT attribute_directory.mark_curr_materialized(attribute_store_id, modified)
      FROM attribute_directory.attribute_store_modified
      WHERE attribute_store_id = $1;

- function:
    name: last_history_id
    schema: attribute_directory
    return_type: integer
    language: plpgsql
    volatility: stable
    arguments:
    - name: attribute_store_id
      data_type: integer
    source: |-
      DECLARE
        result integer;
      BEGIN
        EXECUTE FORMAT(
          'SELECT COALESCE(MAX(id), 0) FROM attribute_history.%I', 
          attribute_directory.to_table_name(attribute_directory.get_attribute_store($1))
        ) INTO result;
        RETURN result;
      END;

- function:
    name: update_compacted
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_compacted
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    - name: compacted
      data_type: integer
    source: |-
      UPDATE attribute_directory.attribute_store_compacted
        SET compacted = greatest(compacted, $2)
        WHERE attribute_store_id = $1
      RETURNING attribute_store_compacted;

- function:
    name: store_compacted
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_compacted
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    - name: compacted
      data_type: integer
    source: |-
      INSERT INTO attribute_directory.attribute_store_compacted (attribute_store_id, compacted)
      VALUES ($1, $2)
      RETURNING attribute_store_compacted;

- function:
    name: mark_compacted
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_compacted
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    - name: compacted
      data_type: integer
    source: |-
      SELECT COALESCE(attribute_directory.update_compacted($1, $2), attribute_directory.store_compacted($1, $2));

- function:
    name: mark_modified
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_modified
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    - name: modified
      data_type: timestamp with time zone
    source: |-
      INSERT INTO attribute_directory.attribute_store_modified (attribute_store_id, modified)
      VALUES ($1, $2)
      ON CONFLICT (attribute_store_id) DO UPDATE
      SET modified = EXCLUDED.modified
      RETURNING attribute_store_modified;

- function:
    name: mark_modified
    schema: attribute_directory
    return_type: attribute_directory.attribute_store_modified
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    source: |-
      SELECT attribute_directory.mark_modified($1, now())

- function:
    name: drop_hash_function
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      BEGIN
          EXECUTE format('DROP FUNCTION attribute_history.values_hash(attribute_history.%I)', attribute_directory.to_table_name($1));

          RETURN $1;
      END;

- function:
    name: define_attribute_store
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_id
      data_type: integer
    - name: entity_type_id
      data_type: integer
    source: |-
      INSERT INTO attribute_directory.attribute_store(data_source_id, entity_type_id)
      VALUES ($1, $2) RETURNING attribute_store;

- function:
    name: define_attribute_store
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    source: |-
      INSERT INTO attribute_directory.attribute_store(data_source_id, entity_type_id)
      VALUES ((directory.name_to_data_source($1)).id, (directory.name_to_entity_type($2)).id);
      SELECT * FROM attribute_directory.attribute_store WHERE data_source_id = (directory.name_to_data_source($1)).id
        AND entity_type_id = (directory.name_to_entity_type($2)).id;

- function:
    name: add_attributes
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - name: attributes
      data_type: attribute_directory.attribute_descr[]
    source: |-
      BEGIN
        INSERT INTO attribute_directory.attribute(attribute_store_id, name, data_type, description) (
            SELECT $1.id, name, data_type, description
            FROM unnest($2) atts
        );
        RETURN $1;
      END;

- function:
    name: get_attribute
    schema: attribute_directory
    return_type: attribute_directory.attribute
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: name
    source: |-
      SELECT attribute
      FROM attribute_directory.attribute
      WHERE attribute_store_id = $1.id AND name = $2;

- function:
    name: define_attribute
    schema: attribute_directory
    return_type: attribute_directory.attribute
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - name: name
      data_type: name
    - name: data_type
      data_type: text
    - name: description
      data_type: text
    source: |-
      INSERT INTO attribute_directory.attribute(attribute_store_id, name, data_type, description)
      VALUES ($1.id, $2, $3, $4)
      RETURNING attribute;

- function:
    name: modify_column_type
    schema: attribute_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: table_name
      data_type: name
    - name: column_name
      data_type: name
    - name: data_type
      data_type: text
    source: |-
      BEGIN
          EXECUTE format('ALTER TABLE attribute_base.%I ALTER %I TYPE %s USING CAST(%I AS %s)', table_name, column_name, data_type, column_name, data_type);
      END;

- function:
    name: modify_column_type
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - name: column_name
      data_type: name
    - name: data_type
      data_type: text
    source: |-
      SELECT attribute_directory.modify_column_type(
          attribute_directory.to_table_name($1), $2, $3
      );

      SELECT $1;

- function:
    name: transfer_staged
    schema: attribute_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      DECLARE
          table_name name;
          columns_part text;
          set_columns_part text;
          default_columns text[];
          row_count integer;
      BEGIN
          table_name = attribute_directory.to_table_name($1);

          default_columns = ARRAY[
              'entity_id',
              '"timestamp"'
          ];

          SELECT array_to_string(default_columns || array_agg(format('%I', name)), ', ') INTO columns_part
          FROM attribute_directory.attribute
          WHERE attribute_store_id = $1.id;

          EXECUTE format(
              'INSERT INTO attribute_history.%I(%s) SELECT %s FROM attribute_staging.%I',
              table_name, columns_part, columns_part, table_name || '_new'
          );

          GET DIAGNOSTICS row_count = ROW_COUNT;

          PERFORM attribute_directory.mark_modified($1.id);

          SELECT array_to_string(array_agg(format('%I = m.%I', name, name)), ', ') INTO set_columns_part
          FROM attribute_directory.attribute
          WHERE attribute_store_id = $1.id;

          EXECUTE format(
              'UPDATE attribute_history.%I a '
              'SET modified = now(), %s '
              'FROM attribute_staging.%I m '
              'WHERE m.entity_id = a.entity_id AND m.timestamp = a.timestamp',
              table_name, set_columns_part, table_name || '_modified'
          );

          EXECUTE format('TRUNCATE attribute_staging.%I', table_name);

          PERFORM attribute_directory.mark_modified($1.id);

          RETURN row_count;
      END;

- function:
    name: transfer_staged
    schema: attribute_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: integer
      name: attribute_store_id
    source: |-
      DECLARE
        attribute attribute_directory.attribute_store;
      BEGIN
        SELECT * FROM attribute_directory.attribute_store WHERE id = $1 INTO attribute;
        RETURN attribute_directory.transfer_staged(attribute);
      END;

- function:
    name: compacted_tmp_table_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_compacted_tmp')::name;

- function:
    name: create_compacted_tmp_table_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE UNLOGGED TABLE attribute_history.%I ('
              '    id integer,'
              '    first_appearance timestamp with time zone,'
              '    modified timestamp with time zone,'
              '    hash text,'
              '    %s'
              ')',
              attribute_directory.compacted_tmp_table_name($1),
              array_to_string(attribute_directory.column_specs($1), ',')
          ),
          format(
              'CREATE INDEX ON attribute_history.%I '
              'USING btree (entity_id, timestamp)',
              attribute_directory.compacted_tmp_table_name($1)
          ),
          format(
              'ALTER TABLE attribute_history.%I '
              'OWNER TO minerva_writer',
              attribute_directory.compacted_tmp_table_name($1)
          ),
          format(
              'SELECT create_distributed_table(''attribute_history.%I'', ''entity_id'')',
              attribute_directory.compacted_tmp_table_name($1)
          )
      ];

- function:
    name: create_compacted_tmp_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_compacted_tmp_table_sql($1)
      );

- function:
    name: drop_compacted_tmp_table_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP TABLE attribute_history.%I',
          attribute_directory.compacted_tmp_table_name($1)
      );

- function:
    name: drop_compacted_tmp_table
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_compacted_tmp_table_sql($1)
      );

- function:
    name: compacted_view_query
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'SELECT %s '
          'FROM attribute_history.%I rl '
          'JOIN attribute_history.%I history ON history.entity_id = rl.entity_id AND history.timestamp = rl.start '
          'WHERE run_length > 1',
          array_to_string(
              ARRAY['rl.id', 'rl.entity_id', 'rl.start AS timestamp', 'rl."end"', 'rl.first_appearance', 'rl.modified', 'history.hash'] || array_agg(quote_ident(name)),
              ', '
          ),
          attribute_directory.run_length_view_name($1),
          attribute_directory.to_table_name($1)
      )
      FROM attribute_directory.attribute
      WHERE attribute_store_id = $1.id;

- function:
    name: create_compacted_view_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE VIEW attribute_history.%I AS %s',
              attribute_directory.compacted_view_name($1),
              attribute_directory.compacted_view_query($1)
          ),
          format(
              'ALTER TABLE attribute_history.%I OWNER TO minerva_writer',
              attribute_directory.compacted_view_name($1)
          )
      ];

- function:
    name: create_compacted_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.create_compacted_view_sql($1)
      );

- function:
    name: drop_compacted_view_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format('DROP VIEW attribute_history.%I', attribute_directory.compacted_view_name($1));

- function:
    name: drop_compacted_view
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_compacted_view_sql($1)
      );

- function:
    name: insert_into_compacted_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT FORMAT(
        'INSERT INTO attribute_directory.attribute_store_compacted '
        '(attribute_store_id, compacted) '
        'VALUES (%s, 0)',
        $1.id
      );

- function:
    name: remove_from_compacted_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT FORMAT(
        'DELETE FROM attribute_directory.attribute_store_compacted '
        'WHERE attribute_store_id = %s',
        $1.id
      );
        
- function:
    name: insert_into_compacted
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.insert_into_compacted_sql($1)
      );

- function:
    name: remove_from_compacted
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.remove_from_compacted_sql($1)
      );
    
- function:
    name: requires_compacting
    schema: attribute_directory
    return_type: bool
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: attribute_store_id
      data_type: integer
    source: |-
      DECLARE
        result bool;
      BEGIN
        SELECT attribute_directory.last_history_id($1) > compacted
          FROM attribute_directory.attribute_store_compacted
          WHERE attribute_store_compacted.attribute_store_id = $1
        INTO result;
        RETURN COALESCE(result, attribute_directory.last_history_id($1) > 0);
      END;

- function:
    name: requires_compacting
    schema: attribute_directory
    return_type: bool
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT attribute_directory.requires_compacting($1.id);

- function:
    name: last_compacted
    schema: attribute_directory
    return_type: integer
    language: sql
    volatility: stable
    arguments:
    - name: attribute_store_id
      data_type: integer
    source: |-
      SELECT COALESCE(compacted, 0) FROM attribute_directory.attribute_store_compacted WHERE attribute_store_id = $1;

- function:
    name: compact
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - name: max_compacting
      data_type: integer
    description: Remove at most max_compacting subsequent records with duplicate attribute values and
      update the modified of the first
    source: |-
      DECLARE
          last_to_compact integer;
          table_name name := attribute_directory.to_table_name($1);
          compacted_tmp_table_name name := table_name || '_compacted_tmp';
          compacted_view_name name := attribute_directory.compacted_view_name($1);
          default_columns text[] := ARRAY['id', 'entity_id', 'timestamp', '"end"', 'first_appearance', 'modified'];
          extended_default_columns text[] := ARRAY[
              format('%I.id', compacted_view_name), format('%I.entity_id', compacted_view_name), 'timestamp', '"end"', 'first_appearance', 'modified'
          ];
          attribute_columns text[];
          columns_part text;
          extended_columns_part text;
          row_count integer;
      BEGIN
          SELECT attribute_directory.last_compacted($1.id) + max_compacting INTO last_to_compact;
          IF max_compacting = 0 OR attribute_directory.last_history_id($1.id) < last_to_compact
              THEN last_to_compact = attribute_directory.last_history_id($1.id);
          END IF;
          
          SELECT array_agg(quote_ident(name)) INTO attribute_columns
              FROM attribute_directory.attribute
              WHERE attribute_store_id = $1.id;
             
          columns_part = array_to_string(default_columns || attribute_columns, ',');
          extended_columns_part = array_to_string(extended_default_columns || attribute_columns, ',');
          EXECUTE format(
              'TRUNCATE attribute_history.%I',
              compacted_tmp_table_name
          );

          EXECUTE format(
              'WITH to_compact AS '
                 '(SELECT entity_id, MIN(id) AS first_id FROM attribute_history.%I '
                 'WHERE id > attribute_directory.last_compacted(%s) GROUP BY entity_id) '
              'INSERT INTO attribute_history.%I(%s) '
                   'SELECT %s FROM attribute_history.%I '
                   'JOIN to_compact '
                   'ON %I.entity_id = to_compact.entity_id '
                   'WHERE first_id <= %s;',
              table_name,
              $1.id,
              compacted_tmp_table_name, columns_part,
              extended_columns_part,
              compacted_view_name,
              compacted_view_name,
              last_to_compact
          );


          EXECUTE format(
              'UPDATE attribute_history.%I SET modified = now()',
              compacted_tmp_table_name
          );

          GET DIAGNOSTICS row_count = ROW_COUNT;

          RAISE NOTICE 'compacted % rows', row_count;

          EXECUTE format(
              'UPDATE attribute_history.%I '
              'SET "end" = "timestamp" '
              'WHERE "end" IS NULL;',
              table_name
          );

          EXECUTE format(
              'DELETE FROM attribute_history.%I history '
              'USING attribute_history.%I tmp '
              'WHERE '
                   'history.entity_id = tmp.entity_id AND '
                   'history.timestamp >= tmp.timestamp AND '
                   'history.timestamp <= tmp."end";',
              table_name, compacted_tmp_table_name
          );

          columns_part = array_to_string(
              ARRAY['id', 'entity_id', 'timestamp', '"end"', 'first_appearance', 'modified'] || attribute_columns,
              ','
          );

          EXECUTE format(
              'INSERT INTO attribute_history.%I(%s) '
              'SELECT %s '
              'FROM attribute_history.%I',
              table_name, columns_part,
              columns_part,
              compacted_tmp_table_name
          );

          PERFORM attribute_directory.mark_modified($1.id);

          PERFORM attribute_directory.mark_compacted($1.id, last_to_compact);

          RETURN $1;
      END;

- function:
    name: compact
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    description: Remove all subsequent records with duplicate attribute values and
      update the modified of the first
    source: |-
      SELECT attribute_directory.compact($1, 0);

- function:
    name: materialize_curr_ptr
    schema: attribute_directory
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      DECLARE
          table_name name := attribute_directory.curr_ptr_table_name($1);
          view_name name := attribute_directory.curr_ptr_view_name($1);
          row_count integer;
      BEGIN
          IF attribute_directory.requires_compacting($1) THEN
              PERFORM attribute_directory.compact($1);
          END IF;

          EXECUTE format('TRUNCATE attribute_history.%I', table_name);
          EXECUTE format(
              'INSERT INTO attribute_history.%I (id) '
              'SELECT id '
              'FROM attribute_history.%I', table_name, view_name
          );

          GET DIAGNOSTICS row_count = ROW_COUNT;

          PERFORM attribute_directory.mark_curr_materialized($1.id);

          RETURN row_count;
      END;

- function:
    name: direct_dependers
    schema: attribute_directory
    return_type: name
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: text
    source: |-
      SELECT dependee.relname AS name
      FROM pg_depend
      JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
      JOIN pg_class as dependee ON pg_rewrite.ev_class = dependee.oid
      JOIN pg_class as dependent ON pg_depend.refobjid = dependent.oid
      JOIN pg_namespace as n ON dependent.relnamespace = n.oid
      JOIN pg_attribute ON
              pg_depend.refobjid = pg_attribute.attrelid
              AND
              pg_depend.refobjsubid = pg_attribute.attnum
      WHERE pg_attribute.attnum > 0 AND dependent.relname = $1;

- function:
    name: dependers
    schema: attribute_directory
    return_type: record
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    - name: level
      data_type: integer
    - name: name
      data_type: name
      mode: t
    - name: level
      data_type: integer
      mode: t
    source: |-
      SELECT (d.dependers).* FROM (
          SELECT attribute_directory.dependers(depender, $2 + 1)
          FROM attribute_directory.direct_dependers($1) depender
      ) d
      UNION ALL
      SELECT depender, $2
      FROM attribute_directory.direct_dependers($1) depender;

- function:
    name: dependers
    schema: attribute_directory
    return_type: record
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    - name: name
      data_type: name
      mode: t
    - name: level
      data_type: integer
      mode: t
    source: |-
      SELECT * FROM attribute_directory.dependers($1, 1);

- function:
    name: at_ptr_function_name
    schema: attribute_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT (attribute_directory.to_table_name($1) || '_at_ptr')::name;

- function:
    name: create_at_func_ptr_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
              format(
                  'CREATE FUNCTION attribute_history.%I(timestamp with time zone)
      RETURNS TABLE(id integer)
      AS $$
          BEGIN
              RETURN QUERY SELECT DISTINCT ON (entity_id) s.id
                  FROM attribute_history.%I s
                  WHERE timestamp <= $1
                  ORDER BY entity_id, timestamp DESC;
          END;
      $$ LANGUAGE plpgsql STABLE',
                  attribute_directory.at_ptr_function_name($1),
                  attribute_directory.to_table_name($1)
              ),
              format(
                  'ALTER FUNCTION attribute_history.%I(timestamp with time zone) '
                  'OWNER TO minerva_writer',
                  attribute_directory.at_ptr_function_name($1)
              )
          ];

- function:
    name: create_at_func_ptr
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      BEGIN
        RETURN public.action(
          $1,
          attribute_directory.create_at_func_ptr_sql($1)
        );
      END;

- function:
    name: drop_at_func_ptr_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP FUNCTION attribute_history.%I(timestamp with time zone)',
          attribute_directory.at_ptr_function_name($1)
      )

- function:
    name: drop_at_func_ptr
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_at_func_ptr_sql($1)
      );

- function:
    name: create_entity_at_func_ptr_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
          format(
              'CREATE FUNCTION attribute_history.%I(entity_id integer, timestamp with time zone)
      RETURNS integer
      AS $$
        BEGIN
          RETURN a.id
          FROM
              attribute_history.%I a
          WHERE a.timestamp <= $2 AND a.entity_id = $1
          ORDER BY a.timestamp DESC LIMIT 1;
        END;
      $$ LANGUAGE plpgsql STABLE',
              attribute_directory.at_ptr_function_name($1),
              attribute_directory.to_table_name($1)
          ),
          format(
              'ALTER FUNCTION attribute_history.%I(entity_id integer, timestamp with time zone) '
              'OWNER TO minerva_writer',
              attribute_directory.at_ptr_function_name($1)
          )
      ];

- function:
    name: create_entity_at_func_ptr
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      BEGIN
        RETURN public.action(
          $1,
          attribute_directory.create_entity_at_func_ptr_sql($1)
        );
      END;

- function:
    name: drop_entity_at_func_ptr_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP FUNCTION attribute_history.%I(entity_id integer, timestamp with time zone)',
          attribute_directory.at_ptr_function_name($1)
      )

- function:
    name: drop_entity_at_func_ptr
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_entity_at_func_ptr_sql($1)
      );

- function:
    name: create_at_func
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          format(
              'CREATE FUNCTION attribute_history.%I(timestamp with time zone)
              RETURNS SETOF attribute_history.%I
              AS $$
                BEGIN
                  RETURN QUERY SELECT a.*
                  FROM
                      attribute_history.%I a
                  JOIN
                      attribute_HISTORY.%I($1) at
                  ON at.id = a.id;
                END;
              $$ LANGUAGE plpgsql STABLE;',
              attribute_directory.at_function_name($1),
              attribute_directory.to_table_name($1),
              attribute_directory.to_table_name($1),
              attribute_directory.at_ptr_function_name($1)
          )
      );

      SELECT public.action(
          $1,
          format(
              'ALTER FUNCTION attribute_history.%I(timestamp with time zone) '
              'OWNER TO minerva_writer',
              attribute_directory.at_function_name($1)
          )
      );

- function:
    name: drop_at_func
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          format(
              'DROP FUNCTION attribute_history.%I(timestamp with time zone)',
              attribute_directory.at_function_name($1)
          )
      );

- function:
    name: drop_entity_at_func_sql
    schema: attribute_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'DROP FUNCTION attribute_history.%I(integer, timestamp with time zone)',
          attribute_directory.at_function_name($1)
      );

- function:
    name: drop_entity_at_func
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT public.action(
          $1,
          attribute_directory.drop_entity_at_func_sql($1)
      );

- function:
    name: create_entity_at_func_sql
    schema: attribute_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT ARRAY[
              format(
                  'CREATE FUNCTION attribute_history.%I(entity_id integer, timestamp with time zone)
          RETURNS attribute_history.%I
      AS $$
      DECLARE
        result attribute_history.%I;
      BEGIN
        SELECT *
          FROM attribute_history.%I
          WHERE id = attribute_history.%I($1, $2)
        INTO result;
        RETURN result;
      END;
      $$ LANGUAGE plpgsql STABLE;',
                  attribute_directory.at_function_name($1),
                  attribute_directory.to_table_name($1),
                  attribute_directory.to_table_name($1),
                  attribute_directory.to_table_name($1),
                  attribute_directory.at_ptr_function_name($1)
              ),
              format(
                  'ALTER FUNCTION attribute_history.%I(entity_id integer, timestamp with time zone) '
                  'OWNER TO minerva_writer',
                  attribute_directory.at_function_name($1)
              )
          ];

- function:
    name: create_entity_at_func
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      BEGIN
        RETURN public.action(
          $1,
          attribute_directory.create_entity_at_func_sql($1)
        );
      END;

- function:
    name: create_dependees
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT attribute_directory.create_staging_new_view($1);
      SELECT attribute_directory.create_staging_modified_view($1);
      SELECT attribute_directory.create_curr_ptr_view($1);
      SELECT attribute_directory.create_curr_view($1);
      SELECT attribute_directory.create_compacted_view($1);
      SELECT attribute_directory.insert_into_compacted($1);
      SELECT $1;

- function:
    name: drop_dependees
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT attribute_directory.drop_compacted_view($1);
      SELECT attribute_directory.drop_curr_view($1);
      SELECT attribute_directory.drop_curr_ptr_view($1);
      SELECT attribute_directory.drop_staging_modified_view($1);
      SELECT attribute_directory.drop_staging_new_view($1);
      SELECT attribute_directory.remove_from_compacted($1);
      SELECT $1;

- function:
    name: update_data_type
    schema: attribute_directory
    return_type: attribute_directory.attribute
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute
    - data_type: text
      name: new_data_type
    source: |-
      UPDATE attribute_directory.attribute SET data_type = $2
        WHERE id = $1.id;
      SELECT
          attribute_directory.create_dependees(
              attribute_directory.modify_column_type(
                  attribute_directory.drop_dependees(attribute_store),
                  $1.name,
                  $2
              )
          )
      FROM attribute_directory.attribute_store
      WHERE id = $1.attribute_store_id;

      SELECT $1;

- function:
    name: check_attribute_types
    schema: attribute_directory
    return_type: attribute_directory.attribute
    returns_set: true
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: attribute_directory.attribute_descr[]
    source: |-
      SELECT attribute_directory.update_data_type(attribute, n.data_type)
        FROM unnest($2) n
        JOIN attribute_directory.attribute
          ON attribute.name = n.name
        WHERE attribute.attribute_store_id = $1.id
          AND attribute.data_type <> trend_directory.greatest_data_type(n.data_type, attribute.data_type);

- function:
    name: drop_hash
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
        SELECT public.action(
            $1,
            ARRAY[
                format('SELECT attribute_directory.drop_compacted_view(%s)', $1),
                format('SELECT attribute_directory.drop_curr_view(%s)', $1),
                format('SELECT attribute_directory.drop_run_length_view(%s)', $1),
                format('SELECT attribute_directory.drop_changes_view(%s)', $1),
                format('ALTER TABLE attribute_history.%I DROP COLUMN hash CASCADE', attribute_directory.attribute_store_to_char($1.id))
            ]
        );

- function:
    name: add_hash
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
        SELECT public.action(
            $1,
            ARRAY[
                format(
                    'ALTER TABLE attribute_history.%I ADD COLUMN hash character varying GENERATED ALWAYS AS (%s) STORED',
                    attribute_directory.attribute_store_to_char($1.id),
                    attribute_directory.hash_query($1)
                ),
                format('SELECT attribute_directory.create_changes_view(%s)', $1),
                format('SELECT attribute_directory.create_run_length_view(%s)', $1),
                format('SELECT attribute_directory.create_compacted_view(%s)', $1),
                format('SELECT attribute_directory.create_curr_view(%s)', $1)
            ]
        );

- function:
    name: drop_staging_dependees
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
        SELECT public.action(
            $1,
            ARRAY[
                format('SELECT attribute_directory.drop_staging_modified_view(%s)', $1),
                format('SELECT attribute_directory.drop_staging_new_view(%s)', $1)
            ]
        );

- function:
    name: add_staging_dependees
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
        SELECT public.action(
            $1,
            ARRAY[
                format('SELECT attribute_directory.create_staging_new_view(%s)', $1),
                format('SELECT attribute_directory.create_staging_modified_view(%s)', $1)
            ]
        );

- function:
    name: add_attribute_column
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: name
    - data_type: text
    source: |-
      SELECT public.action(
          $1,
          ARRAY[
              format('ALTER TABLE attribute_base.%I ADD COLUMN %I %s', attribute_directory.to_char($1), $2, $3),
              format('SELECT attribute_directory.drop_hash(%s::attribute_directory.attribute_store)', $1),
              format('ALTER TABLE attribute_history.%I ADD COLUMN %I %s', attribute_directory.to_char($1), $2, $3),
              format('SELECT attribute_directory.add_hash(%s::attribute_directory.attribute_store)', $1),
              format('ALTER TABLE attribute_history.%I ADD COLUMN %I %s', attribute_directory.compacted_tmp_table_name($1), $2, $3),
              format('SELECT attribute_directory.drop_staging_dependees(%s)', $1),
              format('ALTER TABLE attribute_staging.%I ADD COLUMN %I %s', attribute_directory.to_char($1), $2, $3),
              format('SELECT attribute_directory.add_staging_dependees(%s)', $1)
          ]
      );

- function:
    name: add_attribute_columns
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: attribute_directory.attribute[]
    source: |-
      SELECT public.action(
          $1,
          ARRAY[
              format('SELECT attribute_directory.drop_dependees(attribute_store) FROM attribute_directory.attribute_store WHERE id = %s', $1.id),
              format(
                  'ALTER TABLE attribute_base.%I %s',
                  attribute_directory.to_char($1),
                  (SELECT array_to_string(array_agg(format('ADD COLUMN %I %s', attribute.name, attribute.data_type)), ',') FROM unnest($2) AS attribute)
              ),
              format('SELECT attribute_directory.create_dependees(attribute_store) FROM attribute_directory.attribute_store WHERE id = %s', $1.id)
          ]
      );

- function:
    name: create_attribute
    schema: attribute_directory
    return_type: attribute_directory.attribute
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: name
    - data_type: text
    - data_type: text
    source: |-
      INSERT INTO attribute_directory.attribute(attribute_store_id, name, data_type, description)
      VALUES ($1.id, $2, $3, $4);

      SELECT attribute_directory.add_attribute_column($1, $2, $3);

      SELECT attribute FROM attribute_directory.attribute WHERE attribute_store_id = $1.id AND name = $2;

- function:
    name: remove_attribute_column
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: name
    source: |-
      SELECT public.action(
          $1,
          ARRAY[
              format('SELECT attribute_directory.drop_hash(%s::attribute_directory.attribute_store)', $1),
              format('ALTER TABLE attribute_base.%I DROP COLUMN %I CASCADE', attribute_directory.to_char($1), $2),
              format('ALTER TABLE attribute_history.%I DROP COLUMN %I CASCADE', attribute_directory.to_char($1), $2),
              format('ALTER TABLE attribute_history.%I DROP COLUMN %I CASCADE', attribute_directory.compacted_tmp_table_name($1), $2),
              format('SELECT attribute_directory.add_hash(%s::attribute_directory.attribute_store)', $1),
              format('SELECT attribute_directory.drop_staging_dependees(%s)', $1),
              format('ALTER TABLE attribute_staging.%I DROP COLUMN %I CASCADE', attribute_directory.to_char($1), $2),
              format('SELECT attribute_directory.add_staging_dependees(%s)', $1)
          ]
      );

- function:
    name: drop_attribute
    schema: attribute_directory
    return_type: attribute_directory.attribute_store
    language: sql
    volatility: volatile
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: name
    source: |-
      DELETE FROM attribute_directory.attribute
      WHERE attribute_store_id = $1.id AND name = $2;

      SELECT attribute_directory.remove_attribute_column($1, $2);

- function:
    name: init
    schema: attribute_directory
    return_type: attribute_directory.attribute
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute
    source: |-
      SELECT public.action(
          $1,
          format('SELECT attribute_directory.add_attribute_column(attribute_store, %L, %L) FROM attribute_directory.attribute_store WHERE id = %s', $1.name, $1.data_type, $1.attribute_store_id)
      )

- cast:
    source:
      schema: attribute_directory
      name: attribute_store
    target:
      schema: pg_catalog
      name: text
    function:
      schema: attribute_directory
      name: to_char
    implicit: false

- procedure:
    name: init
    schema: attribute_directory
    language: plpgsql
    arguments:
    - data_type: attribute_directory.attribute_store
    source: |-
      BEGIN
        -- Base table
        PERFORM attribute_directory.create_base_table($1);

        -- Dependent tables
        PERFORM attribute_directory.create_history_table($1);
        PERFORM attribute_directory.create_staging_table($1);
        PERFORM attribute_directory.create_compacted_tmp_table($1);

        -- Separate table
        PERFORM attribute_directory.create_curr_ptr_table($1);

        -- Other
        PERFORM attribute_directory.create_at_func_ptr($1);
        PERFORM attribute_directory.create_at_func($1);

        PERFORM attribute_directory.create_entity_at_func_ptr($1);
        PERFORM attribute_directory.create_entity_at_func($1);

        PERFORM attribute_directory.create_changes_view($1);

        PERFORM attribute_directory.create_run_length_view($1);

        PERFORM attribute_directory.create_dependees($1);

      END;

- function:
    name: deinit
    schema: attribute_directory
    return_type: void
    language: sql
    volatility: volatile
    arguments:
      - data_type: attribute_directory.attribute_store
    source: |-
      -- Other
      SELECT attribute_directory.drop_dependees($1);

      SELECT attribute_directory.drop_run_length_view($1);

      SELECT attribute_directory.drop_changes_view($1);

      SELECT attribute_directory.drop_entity_at_func($1);
      SELECT attribute_directory.drop_entity_at_func_ptr($1);

      SELECT attribute_directory.drop_at_func($1);
      SELECT attribute_directory.drop_at_func_ptr($1);

      SELECT attribute_directory.drop_curr_ptr_table($1);

      -- Dependent tables
      SELECT attribute_directory.drop_compacted_tmp_table($1);
      SELECT attribute_directory.drop_staging_table($1);
      SELECT attribute_directory.drop_history_table($1);

      -- Base/parent table
      SELECT attribute_directory.drop_base_table($1);

- function:
    name: to_attribute
    schema: attribute_directory
    return_type: attribute_directory.attribute
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - name: name
      data_type: name
    - name: data_type
      data_type: text
    - name: description
      data_type: text
    source: |-
      SELECT COALESCE(
              attribute_directory.get_attribute($1, $2),
              attribute_directory.init(attribute_directory.define_attribute($1, $2, $3, $4))
          );

- function:
    name: check_attributes_exist
    schema: attribute_directory
    return_type: attribute_directory.attribute
    returns_set: true
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute_store
    - data_type: attribute_directory.attribute_descr[]
    source: |-
      SELECT attribute_directory.to_attribute($1, n.name, n.data_type, n.description)
          FROM unnest($2) n
          LEFT JOIN attribute_directory.attribute
          ON attribute.attribute_store_id = $1.id AND n.name = attribute.name
          WHERE attribute.name IS NULL;

- procedure:
    name: create_attribute_store
    schema: attribute_directory
    language: plpgsql
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    source: |-
       BEGIN
         CALL attribute_directory.init(attribute_directory.define_attribute_store($1, $2));
       END;

- procedure:
    name: create_attribute_store
    schema: attribute_directory
    language: plpgsql
    arguments:
    - name: data_source_name
      data_type: text
    - name: entity_type_name
      data_type: text
    - name: attributes
      data_type: attribute_directory.attribute_descr[]
    source: |-
      DECLARE
        store attribute_directory.attribute_store;
      BEGIN
        SELECT * FROM attribute_directory.define_attribute_store($1, $2) INTO store;
        PERFORM attribute_directory.add_attributes(store, $3);
        CALL attribute_directory.init(store);
      END;

- procedure:
    name: create_attribute_store
    schema: attribute_directory
    language: sql
    arguments:
    - name: data_source_id
      data_type: integer
    - name: entity_type_id
      data_type: integer
    - name: attributes
      data_type: attribute_directory.attribute_descr[]
    source: |-
      CALL attribute_directory.init(
          attribute_directory.add_attributes(attribute_directory.define_attribute_store($1, $2), $3)
      );

- function:
    name: delete_attribute_store
    schema: attribute_directory
    return_type: void
    language: sql
    arguments:
      - name: attribute_store
        data_type: attribute_directory.attribute_store
    source: |-
      SELECT attribute_directory.deinit($1);
      DELETE FROM attribute_directory.attribute_store WHERE id = $1.id;

- function:
    name: delete_attribute_store
    schema: attribute_directory
    return_type: void
    language: plpgsql
    arguments:
      - name: name
        data_type: text
    source: |-
      DECLARE
        store attribute_directory.attribute_store;
      BEGIN
        SELECT * FROM attribute_directory.attribute_store WHERE attribute_directory.attribute_store_to_char(attribute_store.id) = $1 INTO store;
        PERFORM attribute_directory.delete_attribute_store(store);
      END;

- function:
    name: delete_attribute_store
    schema: attribute_directory
    return_type: void
    language: plpgsql
    arguments:
      - name: attribute_store_id
        data_type: integer
    source: |-
      DECLARE
        store attribute_directory.attribute_store;
      BEGIN
        SELECT * FROM attribute_directory.attribute_store WHERE id = $1 INTO store;
        PERFORM attribute_directory.delete_attribute_store(store);
      END;

- function:
    name: delete_entity_type
    schema: directory
    return_type: void
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
      - data_type: directory.entity_type
    source: |-
      SELECT attribute_directory.delete_attribute_store(s.id) FROM attribute_directory.attribute_store s WHERE s.entity_type_id = $1.id;
      DELETE FROM directory.entity_type WHERE id = $1.id;

- view:
    name: dependencies
    schema: attribute_directory
    query: |2-
       SELECT dependent.relname AS src,
          pg_attribute.attname AS column_name,
          dependee.relname AS dst
         FROM (((((pg_depend
           JOIN pg_rewrite ON ((pg_depend.objid = pg_rewrite.oid)))
           JOIN pg_class dependee ON ((pg_rewrite.ev_class = dependee.oid)))
           JOIN pg_class dependent ON ((pg_depend.refobjid = dependent.oid)))
           JOIN pg_namespace n ON ((dependent.relnamespace = n.oid)))
           JOIN pg_attribute ON (((pg_depend.refobjid = pg_attribute.attrelid) AND (pg_depend.refobjsubid = pg_attribute.attnum))))
        WHERE ((n.nspname = 'attribute_directory'::name) AND (pg_attribute.attnum > 0));
    privileges:
    - role: minerva
      privilege: SELECT

- function:
    name: view_to_attribute_staging_sql
    schema: attribute_directory
    return_type: text
    language: sql
    arguments:
    - name: view
      data_type: text
    - data_type: attribute_directory.attribute_store
    source: |-
      SELECT format(
          'INSERT INTO attribute_staging.%1$I(%2$s) SELECT %2$s FROM %3$s',
          attribute_directory.to_table_name($2),
          array_to_string(ARRAY['entity_id', 'timestamp']::text[] || array_agg(quote_ident(attribute.name)), ', '),
          $1::regclass::text
      )
      FROM attribute_directory.attribute
      WHERE attribute_store_id = $2.id;

- function:
    name: stage_sample
    schema: attribute_directory
    return_type: integer
    language: sql
    arguments:
    - data_type: attribute_directory.sampled_view_materialization
    source: |-
      SELECT public.action_count(
          attribute_directory.view_to_attribute_staging_sql($1.src_view, attribute_store)
      )
      FROM attribute_directory.attribute_store
      WHERE id = $1.attribute_store_id

- function:
    name: materialize
    schema: attribute_directory
    return_type: integer
    language: sql
    arguments:
    - data_type: attribute_directory.sampled_view_materialization
    source: |-
      SELECT attribute_directory.stage_sample($1);

      SELECT attribute_directory.transfer_staged(attribute_store)
      FROM attribute_directory.attribute_store
      WHERE id = $1.attribute_store_id;

- function:
    name: modify_data_type
    schema: attribute_directory
    return_type: attribute_directory.attribute
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: attribute_directory.attribute
    source: |-
      DECLARE
        store attribute_directory.attribute_store;
      BEGIN
        SELECT * FROM attribute_directory.attribute_store WHERE id = $1.attribute_store_id INTO store;
        RETURN public.action(
            $1,
            ARRAY[
                format('ALTER TABLE attribute_base.%I ALTER %I TYPE %s', attribute_directory.to_char(store), $1.name, $1.data_type),
                format('SELECT attribute_directory.drop_hash(%s::attribute_directory.attribute_store)', store),
                format('ALTER TABLE attribute_history.%I ALTER %I TYPE %s', attribute_directory.to_char(store), $1.name, $1.data_type),
                format('SELECT attribute_directory.add_hash(%s::attribute_directory.attribute_store)', store),
                format('ALTER TABLE attribute_history.%I ALTER %I TYPE %s', attribute_directory.compacted_tmp_table_name(store), $1.name, $1.data_type),
                format('SELECT attribute_directory.drop_staging_dependees(%s)', store),
                format('ALTER TABLE attribute_staging.%I ALTER %I TYPE %s', attribute_directory.to_char(store), $1.name, $1.data_type),
                format('SELECT attribute_directory.add_staging_dependees(%s)', store)
            ]
        );
      END;

- function:
    name: update_data_type_on_change
    schema: attribute_directory
    return_type: trigger
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments: []
    source: |-
      BEGIN
          IF OLD.data_type <> NEW.data_type THEN
              PERFORM attribute_directory.modify_data_type(NEW);
          END IF;

          RETURN NEW;
      END;

- trigger:
    table:
      schema: attribute_directory
      name: attribute
    name: update_attribute_type
    function:
      schema: attribute_directory
      name: update_data_type_on_change
    when: after
    events:
    - update
    affecteach: row


##########################
##########################
##                      ##
## Notification Storage ##
##                      ##
##########################
##########################

- composite_type:
    name: attr_def
    schema: notification_directory
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: name
      nullable: false
    - name: description
      data_type: text
      nullable: false

- sequence:
    name: notification_store_id_seq
    schema: notification_directory
    startvalue: 1
    increment: 1

- table:
    name: notification_store
    schema: notification_directory
    description: |-
      Describes notification_stores. Each notification_store maps to a set of
      tables and functions that can store and manage notifications of a certain
      type. These corresponding tables and functions are created automatically
      for each notification_store. Because each notification_store maps
      one-on-one to a data_source, the name of the notification_store is the
      same as that of the data_source. Use the create_notification_store
      function to create new notification_stores.
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: data_source_id
      data_type: integer
      nullable: true
    primary_key:
      name: notification_store_pkey
      columns:
      - id
    foreign_keys:
    - name: notification_store_data_source_id_fkey
      columns:
      - data_source_id
      references:
        table:
          name: data_source
          schema: directory
        columns:
        - id
      on_delete: cascade
    indexes:
    - name: uniqueness
      unique: true
      definition: btree (data_source_id)
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: attribute
    schema: notification_directory
    description: |-
      Describes attributes of notification stores. An attribute of a
      notification store is an attribute that each notification stored in that
      notification store has. An attribute corresponds directly to a column in
      the main notification store table
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: notification_store_id
      data_type: integer
      nullable: true
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: name
      nullable: false
    - name: description
      data_type: varchar
      nullable: false
    primary_key:
      name: attribute_pkey
      columns:
      - id
    foreign_keys:
    - name: attribute_notification_store_id_fkey
      columns:
      - notification_store_id
      references:
        table:
          name: notification_store
          schema: notification_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: notification_set_store
    schema: notification_directory
    description: |-
      Describes notification_set_stores. A notification_set_store can hold information over sets of notifications that are related to each other.
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: name
      nullable: false
    - name: notification_store_id
      data_type: integer
      nullable: true
    primary_key:
      name: notification_set_store_pkey
      columns:
      - id
    foreign_keys:
    - name: notification_set_store_notification_store_id_fkey
      columns:
      - notification_store_id
      references:
        table:
          name: notification_store
          schema: notification_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- table:
    name: set_attribute
    schema: notification_directory
    description: |-
      Describes attributes of notification_set_stores. A set_attribute of a
      notification_set_store is an attribute that each notification set has. A
      set_attribute corresponds directly to a column in the main
      notification_set_store table.
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: notification_set_store_id
      data_type: integer
      nullable: true
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: name
      nullable: false
    - name: description
      data_type: varchar
      nullable: false
    primary_key:
      name: set_attribute_pkey
      columns:
      - id
    foreign_keys:
    - name: set_attribute_notification_set_store_id_fkey
      columns:
      - notification_set_store_id
      references:
        table:
          name: notification_set_store
          schema: notification_directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: INSERT,UPDATE,DELETE

- function:
    name: notification_store_schema
    schema: notification_directory
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments: []
    source: |-
      SELECT 'notification'::name;

- function:
    name: to_char
    schema: notification_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT data_source.name
      FROM directory.data_source
      WHERE data_source.id = $1.data_source_id;

- function:
    name: notification_store_to_char
    schema: notification_directory
    return_type: text
    language: sql
    volatility: stable
    strict: true
    secdef: false
    arguments:
    - data_type: integer
      name: notification_store_id
    source: |-
      SELECT data_source.name
        FROM notification_directory.notification_store
          JOIN directory.data_source ON data_source.id = notification_store.data_source_id
        WHERE notification_store.id = $1;

- function:
    name: table_name
    schema: notification_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT name::name
      FROM directory.data_source
      WHERE id = $1.data_source_id;

- function:
    name: staging_table_name
    schema: notification_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT (notification_directory.table_name($1) || '_staging')::name;

- function:
    name: create_table_sql
    schema: notification_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT ARRAY[
              format(
                  'CREATE TABLE %I.%I ('
                  '  id serial PRIMARY KEY,'
                  '  entity_id integer NOT NULL,'
                  '  "timestamp" timestamp with time zone NOT NULL'
                  '  %s'
                  ');',
                  notification_directory.notification_store_schema(),
                  notification_directory.table_name($1),
                  (SELECT array_to_string(array_agg(format(',%I %s', name, data_type)), ' ') FROM notification_directory.attribute WHERE notification_store_id = $1.id)
              ),
              format(
                  'ALTER TABLE %I.%I OWNER TO minerva_writer;',
                  notification_directory.notification_store_schema(),
                  notification_directory.table_name($1)
              ),
              format(
                  'CREATE INDEX %I ON %I.%I USING btree (timestamp);',
                  'idx_notification_' || notification_directory.table_name($1) || '_timestamp',
                  notification_directory.notification_store_schema(),
                  notification_directory.table_name($1)
              )
          ];

- function:
    name: create_table
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT public.action($1, notification_directory.create_table_sql($1));

- function:
    name: create_staging_table_sql
    schema: notification_directory
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT ARRAY[
              format(
                  'CREATE TABLE %I.%I ('
                  '  entity_id integer NOT NULL,'
                  '  "timestamp" timestamp with time zone NOT NULL'
                  '  %s'
                  ');',
                  notification_directory.notification_store_schema(),
                  notification_directory.staging_table_name($1),
                  (SELECT array_to_string(array_agg(format(',%I %s', name, data_type)), ' ') FROM notification_directory.attribute WHERE notification_store_id = $1.id)
              ),
              format(
                  'ALTER TABLE %I.%I OWNER TO minerva_writer;',
                  notification_directory.notification_store_schema(),
                  notification_directory.staging_table_name($1)
              )
          ];

- function:
    name: create_staging_table
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT public.action($1, notification_directory.create_staging_table_sql($1));

- function:
    name: drop_staging_table_sql
    schema: notification_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT format(
          'DROP TABLE %I.%I',
          notification_directory.notification_store_schema(),
          notification_directory.staging_table_name($1)
      );

- function:
    name: drop_staging_table
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT public.action($1, notification_directory.drop_staging_table_sql($1));

- function:
    name: initialize_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT notification_directory.create_table($1);
      SELECT notification_directory.create_staging_table($1);

- function:
    name: define_attribute
    schema: notification_directory
    return_type: notification_directory.attribute
    returns_set: true
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    - data_type: name
    - data_type: name
    - data_type: text
    source: |-
      INSERT INTO notification_directory.attribute(notification_store_id, name, data_type, description)
      VALUES($1.id, $2, $3, $4) RETURNING *;

- function:
    name: define_attributes
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    - data_type: notification_directory.attr_def[]
    source: |-
      SELECT notification_directory.define_attribute($1, name, data_type, description)
      FROM unnest($2);

      SELECT $1;

- function:
    name: define_notification_set_store
    schema: notification_directory
    return_type: notification_directory.notification_set_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    - name: notification_store_id
      data_type: integer
    source: |-
      INSERT INTO notification_directory.notification_set_store(name, notification_store_id)
      VALUES ($1, $2)
      RETURNING *;

- function:
    name: notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_set_store
    source: |-
      SELECT notification_store FROM notification_directory.notification_store WHERE id = $1.notification_store_id;

- function:
    name: get_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: name
    source: |-
      SELECT ns
      FROM notification_directory.notification_store ns
      JOIN directory.data_source ds ON ds.id = ns.data_source_id
      WHERE ds.name = $1;

- function:
    name: define_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_id
      data_type: integer
    source: |-
      INSERT INTO notification_directory.notification_store(data_source_id)
      VALUES ($1)
      RETURNING *;

- function:
    name: define_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_id
      data_type: integer
    - data_type: notification_directory.attr_def[]
    source: |-
      SELECT notification_directory.define_attributes(
          notification_directory.define_notification_store($1),
          $2
      );

- function:
    name: create_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_id
      data_type: integer
    - data_type: notification_directory.attr_def[]
    source: |-
      SELECT notification_directory.initialize_notification_store(
          notification_directory.define_notification_store($1, $2)
      );

- function:
    name: create_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    - data_type: notification_directory.attr_def[]
    source: |-
      SELECT notification_directory.create_notification_store(
          (directory.name_to_data_source($1)).id, $2
      );

- function:
    name: create_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_id
      data_type: integer
    source: |-
      SELECT notification_directory.create_notification_store(
          $1, ARRAY[]::notification_directory.attr_def[]
      );

- function:
    name: create_notification_store
    schema: notification_directory
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: data_source_name
      data_type: text
    source: |-
      SELECT notification_directory.create_notification_store(
          (directory.name_to_data_source($1)).id
      );

- function:
    name: delete_notification_store
    schema: notification_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      BEGIN
          EXECUTE format(
              'DROP TABLE IF EXISTS %I.%I CASCADE',
              notification_directory.notification_store_schema(),
              notification_directory.staging_table_name($1)
          );

          EXECUTE format(
              'DROP TABLE IF EXISTS %I.%I CASCADE',
              notification_directory.notification_store_schema(),
              notification_directory.table_name($1)
          );

          DELETE FROM notification_directory.notification_store WHERE id = $1.id;
      END;


- function:
    name: init_notification_set_store
    schema: notification_directory
    return_type: notification_directory.notification_set_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_set_store
    source: |-
      BEGIN
          EXECUTE format(
              'CREATE TABLE %I.%I('
              '  id serial PRIMARY KEY'
              ')',
              notification_directory.notification_store_schema(),
              $1.name
          );

          EXECUTE format(
              'CREATE TABLE %I.%I('
              '  notification_id integer REFERENCES %I.%I ON DELETE CASCADE,'
              '  set_id integer REFERENCES %I.%I ON DELETE CASCADE'
              ')',
              notification_directory.notification_store_schema(),
              $1.name || '_link',
              notification_directory.notification_store_schema(),
              notification_directory.table_name(notification_directory.notification_store($1)),
              notification_directory.notification_store_schema(),
              $1.name
          );

          RETURN $1;
      END;

- function:
    name: create_notification_set_store
    schema: notification_directory
    return_type: notification_directory.notification_set_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    - name: notification_store_id
      data_type: integer
    source: |-
      SELECT notification_directory.init_notification_set_store(
          notification_directory.define_notification_set_store($1, $2)
      );

- function:
    name: create_notification_set_store
    schema: notification_directory
    return_type: notification_directory.notification_set_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    - data_type: notification_directory.notification_store
    source: |-
      SELECT notification_directory.create_notification_set_store($1, $2.id);

- function:
    name: delete_notification_set_store
    schema: notification_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_set_store
    source: |-
      BEGIN
          EXECUTE format(
              'DROP TABLE IF EXISTS %I.%I',
              notification_directory.notification_store_schema(),
              $1.name || '_link'
          );

          EXECUTE format(
              'DROP TABLE IF EXISTS %I.%I',
              notification_directory.notification_store_schema(),
              $1.name
          );

          DELETE FROM notification_directory.notification_set_store WHERE id = $1.id;
      END;

- function:
    name: get_column_type_name
    schema: notification_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: namespace_name
      data_type: name
    - name: table_name
      data_type: name
    - name: column_name
      data_type: name
    source: |-
      SELECT typname
      FROM pg_type
      JOIN pg_attribute ON pg_attribute.atttypid = pg_type.oid
      JOIN pg_class ON pg_class.oid = pg_attribute.attrelid
      JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace
      WHERE nspname = $1 AND relname = $2 AND attname = $3 AND attnum > 0 AND not pg_attribute.attisdropped;

- function:
    name: get_column_type_name
    schema: notification_directory
    return_type: name
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    - data_type: name
    source: |-
      SELECT notification_directory.get_column_type_name(
          notification_directory.notification_store_schema(),
          notification_directory.table_name($1),
          $2
      );

- function:
    name: add_attribute_column_sql
    schema: notification_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: name
    - data_type: notification_directory.attribute
    source: |-
      SELECT format(
          'ALTER TABLE %I.%I ADD COLUMN %I %s',
          notification_directory.notification_store_schema(),
          $1, $2.name, $2.data_type
      );

- function:
    name: add_staging_attribute_column_sql
    schema: notification_directory
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.attribute
    source: |-
      SELECT
          format(
              'ALTER TABLE %I.%I ADD COLUMN %I %s',
              notification_directory.notification_store_schema(),
              notification_directory.staging_table_name(notification_store), $1.name, $1.data_type
          )
      FROM notification_directory.notification_store WHERE id = $1.notification_store_id;

- function:
    name: create_attribute_column
    schema: notification_directory
    return_type: notification_directory.attribute
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.attribute
    source: |-
      SELECT public.action(
          $1,
          notification_directory.add_attribute_column_sql(
              notification_directory.table_name(notification_store),
              $1
          )
      )
      FROM notification_directory.notification_store WHERE id = $1.notification_store_id;

      SELECT public.action(
          $1,
          notification_directory.add_attribute_column_sql(
              notification_directory.staging_table_name(notification_store),
              $1
          )
      )
      FROM notification_directory.notification_store WHERE id = $1.notification_store_id;

- function:
    name: get_attr_defs
    schema: notification_directory
    return_type: notification_directory.attr_def
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      SELECT (attname, typname, '')::notification_directory.attr_def
      FROM pg_type
      JOIN pg_attribute ON pg_attribute.atttypid = pg_type.oid
      JOIN pg_class ON pg_class.oid = pg_attribute.attrelid
      JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace
      WHERE
      nspname = notification_directory.notification_store_schema() AND
      relname = notification_directory.table_name($1) AND
      attnum > 0 AND
      NOT attname IN ('id', 'entity_id', 'timestamp') AND
      NOT pg_attribute.attisdropped;

- cast:
    source:
      schema: notification_directory
      name: notification_store
    target:
      schema: pg_catalog
      name: text
    function:
      schema: notification_directory
      name: to_char
    implicit: false

- function:
    name: cleanup_on_data_source_delete
    schema: directory
    return_type: void
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
      - data_type: integer
        name: data_source_id
    source: |-
      SELECT attribute_directory.delete_attribute_store(s.id) FROM attribute_directory.attribute_store s WHERE s.data_source_id = $1;
      DELETE FROM notification_directory.notification_store WHERE data_source_id = $1;

- function:
    name: delete_data_source
    schema: directory
    return_type: directory.data_source
    language: sql
    volatility: volatile
    strict: true
    secdef: false
    arguments:
    - data_type: text
    source: |-
      SELECT directory.cleanup_on_data_source_delete(s.id) FROM directory.data_source s WHERE s.name = $1;
      DELETE FROM directory.data_source WHERE name = $1 RETURNING *;

- function:
    name: update
    schema: virtual_entity
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: name
      data_type: name
    source: |-
      DECLARE
          result integer;
      BEGIN
          EXECUTE format(
              'SELECT count(entity.%I(v.name)) FROM virtual_entity.%I v LEFT JOIN entity.%I e ON e.name = v.name WHERE e.name IS NULL',
              format('to_%s', name), name, name
          ) INTO result;

          RETURN result;
      END;

######################
######################
##                  ##
## Schema 'trigger' ##
##                  ##
######################
######################

- composite_type:
    name: threshold_def
    schema: trigger
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: name
      nullable: false

- composite_type:
    name: kpi_def
    schema: trigger
    columns:
    - name: name
      data_type: name
      nullable: false
    - name: data_type
      data_type: name
      nullable: false

- composite_type:
    name: notification
    schema: trigger
    columns:
    - name: entity_id
      data_type: integer
      nullable: false
    - name: timestamp
      data_type: timestamp with time zone
      nullable: false
    - name: weight
      data_type: integer
      nullable: false
    - name: details
      data_type: text
      nullable: false
    - name: data
      data_type: json
      nullable: false

- table:
    name: rule
    schema: trigger
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: name
      data_type: name
      nullable: true
    - name: notification_store_id
      data_type: integer
      nullable: true
    - name: granularity
      data_type: interval
      nullable: true
    - name: default_interval
      data_type: interval
      nullable: true
    - name: enabled
      data_type: bool
      nullable: false
      default: 'false'
    - name: description
      data_type: text
      nullable: true
    primary_key:
      name: rule_pkey
      columns:
      - id
    foreign_keys:
    - name: rule_notification_store_id_fkey
      columns:
      - notification_store_id
      references:
        table:
          name: notification_store
          schema: notification_directory
        columns:
        - id
    indexes:
    - name: rule_name_key
      unique: true
      definition: btree (name)
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: UPDATE

- table:
    name: rule_trend_store_link
    schema: trigger
    description: >
      Stores the dependencies between a trigger rule and its source table trend
      store parts. Multiple levels of views and functions may exist between a
      materialization and its source table trend stores. These intermediate views and
      functions are not registered here, but only the table trend stores containing
      the actual source data used in the trigger rule.

      The timestamp_mapping_func column stores the function to map a timestamp
      of the source (trend_store_part) to a timestamp of the target notification.
    columns:
    - name: rule_id
      data_type: integer
      nullable: false
      description: Reference to a trigger rule.
    - name: trend_store_part_id
      data_type: integer
      nullable: false
      description: >
        Reference to a trend_store_part that is a source of the
        materialization referenced by materialization_id.
    - name: timestamp_mapping_func
      data_type: regprocedure
      nullable: false
      description: >
        The function that maps timestamps in the source table to timestamps in
        the materialized data. For example, for a view for an hour aggregation from 15 minute
        granularity data will need to map 4 timestamps in the source to 1 timestamp in
        the resulting data.
    foreign_keys:
    - name: rule_trend_store_link_rule_id_fkey
      columns:
      - rule_id
      references:
        table:
          name: rule
          schema: trigger
        columns:
        - id
      on_delete: cascade
    - name: rule_trend_store_link_trend_store_part_id_fkey
      columns:
      - trend_store_part_id
      references:
        table:
          name: trend_store_part
          schema: trend_directory
        columns:
        - id
      on_delete: cascade
    primary_key:
      name: materialization_trend_store_link_pkey
      columns:
      - rule_id
      - trend_store_part_id

- table:
    name: exception_base
    schema: trigger
    columns:
    - name: id
      data_type: serial
      nullable: false
    - name: entity_id
      data_type: integer
      nullable: true
    - name: start
      data_type: timestamp with time zone
      nullable: true
    - name: expires
      data_type: timestamp with time zone
      nullable: true
    - name: created
      data_type: timestamp with time zone
      nullable: true
      default: now()
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: UPDATE

- table:
    name: rule_tag_link
    schema: trigger
    columns:
    - name: rule_id
      data_type: integer
      nullable: false
    - name: tag_id
      data_type: integer
      nullable: false
    primary_key:
      name: rule_tag_link_pkey
      columns:
      - rule_id
      - tag_id
    foreign_keys:
    - name: rule_tag_link_rule_id_fkey
      columns:
      - rule_id
      references:
        table:
          name: rule
          schema: trigger
        columns:
        - id
      on_delete: cascade
    - name: rule_tag_link_tag_id_fkey
      columns:
      - tag_id
      references:
        table:
          name: tag
          schema: directory
        columns:
        - id
      on_delete: cascade
    privileges:
    - role: minerva
      privilege: SELECT
    - role: minerva_writer
      privilege: UPDATE

- function:
    name: table_exists
    schema: trigger
    return_type: bool
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: schema_name
      data_type: name
    - name: table_name
      data_type: name
    source: |-
      SELECT exists(
          SELECT 1
          FROM pg_class
          JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
          WHERE relname = $2 AND relkind = 'r' AND pg_namespace.nspname = $1
      );

- function:
    name: view_exists
    schema: trigger
    return_type: bool
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - name: schema_name
      data_type: name
    - name: table_name
      data_type: name
    source: |-
      SELECT exists(
          SELECT 1
          FROM pg_class
          JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
          WHERE relname = $2 AND relkind = 'v' AND pg_namespace.nspname = $1
      );

- function:
    name: action
    schema: trigger
    return_type: anyelement
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: anyelement
    - name: sql
      data_type: text
    source: |-
      BEGIN
          EXECUTE sql;

          RETURN $1;
      END;

- function:
    name: action
    schema: trigger
    return_type: anyelement
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: anyelement
    - name: sql
      data_type: text[]
    source: |-
      DECLARE
          statement text;
      BEGIN
          FOREACH statement IN ARRAY sql LOOP
              EXECUTE statement;
          END LOOP;

          RETURN $1;
      END;

- function:
    name: with_threshold_view_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_with_threshold')::name;

- function:
    name: weight_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_weight')::name;

- function:
    name: exception_weight_table_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_exception_weight')::name;

- function:
    name: exception_threshold_table_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_exception_threshold')::name;

- function:
    name: notification_view_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_notification')::name;

- function:
    name: get_rule
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: name
    source: |-
      SELECT rule FROM "trigger".rule WHERE name = $1;

- function:
    name: add_rule
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    source: |-
      INSERT INTO "trigger".rule (name)
      VALUES ($1) RETURNING rule;

- function:
    name: define
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    source: |-
      SELECT COALESCE(trigger.get_rule($1), trigger.add_rule($1));

- function:
    name: threshold_view_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_threshold')::name;

- function:
    name: rule_view_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT $1.name;

- function:
    name: get_rule_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: "SELECT\n\tpg_get_viewdef(oid, true)\nFROM pg_class\nWHERE relname = trigger.rule_view_name($1);"

- function:
    name: rule_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - name: where_clause
      data_type: text
    source: |-
      SELECT format(
          'SELECT * FROM trigger_rule.%I WHERE %s;',
          trigger.with_threshold_view_name($1), $2
      );

- function:
    name: drop_rule_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP VIEW trigger_rule.%I CASCADE', $1.name);

- function:
    name: create_rule_view_sql
    schema: trigger
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - name: rule_view_sql
      data_type: text
    source: |-
      SELECT ARRAY[
          format('CREATE OR REPLACE VIEW trigger_rule.%I AS %s', trigger.rule_view_name($1), $2),
          format('ALTER VIEW trigger_rule.%I OWNER TO minerva_admin', trigger.rule_view_name($1))
      ];

- function:
    name: create_rule_view
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: true
    arguments:
    - data_type: trigger.rule
    - name: rule_view_sql
      data_type: text
    source: |-
      SELECT trigger.action($1, trigger.create_rule_view_sql($1, $2));

- function:
    name: kpi_view_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_kpi')::name;

- function:
    name: kpi_function_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_kpi')::name;

- function:
    name: get_kpi_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT pg_get_viewdef(oid, true)
      FROM pg_class
      WHERE relname = trigger.kpi_view_name($1);

- function:
    name: kpi_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - name: sql
      data_type: text
    source: |-
      SELECT format(
          'DROP VIEW IF EXISTS trigger_rule.%I',
          "trigger".kpi_view_name($1)
      );
      SELECT format(
          'CREATE VIEW trigger_rule.%I AS %s',
          "trigger".kpi_view_name($1), $2
      );

- function:
    name: drop_kpi_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP VIEW trigger_rule.%I CASCADE', "trigger".kpi_view_name($1));

- function:
    name: drop_kpi_function_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP FUNCTION trigger_rule.%I(timestamp with time zone) CASCADE', "trigger".kpi_function_name($1));

- function:
    name: create_kpi_view_sql
    schema: trigger
    return_type: text[]
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - name: sql
      data_type: text
    source: |-
      SELECT ARRAY[
          trigger.kpi_view_sql($1, $2),
          format('ALTER VIEW trigger_rule.%I OWNER TO minerva_admin', trigger.kpi_view_name($1))
      ];

- function:
    name: create_kpi_view
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - name: sql
      data_type: text
    source: |-
      SELECT trigger.action($1, trigger.create_kpi_view_sql($1, $2));

- function:
    name: kpi_type_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_kpi')::name;

- function:
    name: details_type_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_details')::name;

- function:
    name: notification_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_create_notification')::name;

- function:
    name: notification_threshold_test_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_notification_test_threshold')::name;

- function:
    name: notification_test_threshold_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'CREATE OR REPLACE FUNCTION trigger_rule.%I AS
      SELECT
          n.entity_id,
          n.timestamp,
          trigger_rule.%I(n) AS weight,
          trigger_rule.%I(n) AS details
      FROM trigger_rule.%I AS n',
          trigger.notification_threshold_test_fn_name($1),
          trigger.weight_fn_name($1),
          trigger.notification_fn_name($1),
          $1.name
      );

- function:
    name: get_with_threshold_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: 
      SELECT
          pg_get_viewdef(oid, true)
      FROM pg_class
      WHERE relname = trigger.with_threshold_view_name($1);

- function:
    name: get_threshold_defs
    schema: trigger
    return_type: trigger.kpi_def
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT (attname, typname)::trigger.kpi_def
      FROM pg_type
      JOIN pg_attribute ON pg_attribute.atttypid = pg_type.oid
      JOIN pg_class ON pg_class.oid = pg_attribute.attrelid
      JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace
      WHERE
      nspname = 'trigger_rule' AND
      relname = "trigger".threshold_view_name($1) AND
      attnum > 0 AND
      NOT pg_attribute.attisdropped;

- function:
    name: with_threshold_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
      $view$
      SELECT
          kpi.*,
          %s
      FROM trigger_rule.%I AS threshold, trigger_rule.%I AS kpi
      LEFT JOIN trigger_rule.%I exc ON
          exc.entity_id = kpi.entity_id AND
          exc.start <= timestamp AND
          exc.expires > timestamp
      $view$,
          array_to_string(array_agg(format('COALESCE(exc.%I, threshold.%I) AS %I', kpi.name, kpi.name, 'threshold_' || kpi.name)), ', '),
          trigger.threshold_view_name($1),
          trigger.kpi_view_name($1),
          trigger.exception_threshold_table_name($1)
      )
      FROM trigger.get_threshold_defs($1) kpi;

- function:
    name: create_with_threshold_view
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.action($1, format('CREATE OR REPLACE VIEW trigger_rule.%I AS %s', trigger.with_threshold_view_name($1), trigger.with_threshold_view_sql($1)));
      SELECT trigger.action($1, format('ALTER VIEW trigger_rule.%I OWNER TO minerva_admin', trigger.with_threshold_view_name($1)));

- function:
    name: drop_with_threshold_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP VIEW trigger_rule.%I', trigger.with_threshold_view_name($1));

- function:
    name: get_weight_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT pg_get_functiondef(oid) FROM pg_proc WHERE proname = trigger.weight_fn_name($1);

- function:
    name: weight_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - name: expression
      data_type: text
    source: |-
      SELECT format(
        $function$
        CREATE OR REPLACE FUNCTION trigger_rule.%I(trigger_rule.%I)
            RETURNS integer AS
        $weight_fn$SELECT (%s)$weight_fn$ LANGUAGE SQL IMMUTABLE;
        $function$,
        trigger.weight_fn_name($1),
        trigger.details_type_name($1),
        $2
      );

- function:
    name: drop_weight_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP FUNCTION trigger_rule.%I(trigger_rule.%I)',
          trigger.weight_fn_name($1),
          trigger.details_type_name($1)
      );

- function:
    name: exception_weight_table_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          $$CREATE TABLE trigger_rule.%I
          (
              id serial,
              entity_id integer,
              created timestamp with time zone not null default now(),
              start timestamp with time zone not null default now(),
              expires timestamp with time zone not null default now() + interval '3 months',
              weight integer not null
          );$$,
          trigger.exception_weight_table_name($1)
      );

- function:
    name: create_exception_weight_table
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: "SELECT trigger.action($1, trigger.exception_weight_table_sql($1));\n\
      SELECT trigger.action($1, format('ALTER TABLE trigger_rule.%I OWNER TO minerva_admin',\
      \ trigger.exception_weight_table_name($1)));"

- function:
    name: drop_exception_weight_table_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP TABLE IF EXISTS trigger_rule.%I', trigger.exception_weight_table_name($1));

- function:
    name: notification_type_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_notification_details')::name;

- function:
    name: create_notification_type_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          $type$
          CREATE TYPE trigger_rule.%I AS (
              entity_id integer,
              timestamp timestamp with time zone,
              details text
          )
          $type$,
          trigger.notification_type_name($1)
      );

- function:
    name: drop_notification_type_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP TYPE IF EXISTS trigger_rule.%I',
          trigger.notification_type_name($1)
      );

- function:
    name: create_notification_type
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.action(
          $1,
          trigger.create_notification_type_sql($1)
      );

- function:
    name: drop_exception_threshold_table_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP TABLE IF EXISTS trigger_rule.%I', trigger.exception_threshold_table_name($1))

- function:
    name: get_kpi_defs
    schema: trigger
    return_type: trigger.kpi_def
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT (attname, typname)::trigger.kpi_def
      FROM pg_type
      JOIN pg_attribute ON pg_attribute.atttypid = pg_type.oid
      JOIN pg_class ON pg_class.oid = pg_attribute.attrelid
      JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace
      WHERE
      nspname = 'trigger_rule' AND
      relname = "trigger".kpi_view_name($1) AND
      attnum > 0 AND
      NOT attname IN ('entity_id', 'timestamp') AND
      NOT pg_attribute.attisdropped;

- function:
    name: get_kpi_def
    schema: trigger
    return_type: trigger.kpi_def
    language: plpgsql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - data_type: name
    source: |-
      DECLARE
          result trigger.kpi_def;
      BEGIN
          SELECT INTO result * FROM trigger.get_kpi_defs($1) WHERE name = $2;

          IF NOT FOUND THEN
              RAISE EXCEPTION 'no such KPI: ''%''', $2;
          END IF;

          RETURN result;
      END;

- function:
    name: get_exception_threshold_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_get_exception_threshold')::name;

- function:
    name: create_exception_threshold_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_create_exception_threshold')::name;

- function:
    name: get_or_create_exception_threshold_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_get_or_create_exception_threshold')::name;

- function:
    name: change_exception_threshold_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_add_or_change_threshold_exception')::name;

- function:
    name: get_exception_threshold_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
        'CREATE OR REPLACE FUNCTION trigger_rule.%I(entity integer) RETURNS trigger_rule.%I AS $fn$%s$fn$ LANGUAGE sql VOLATILE',
        trigger.get_exception_threshold_fn_name($1),
        trigger.exception_threshold_table_name($1),
        format(
          'SELECT * FROM trigger_rule.%I WHERE entity_id = entity;',
          trigger.exception_threshold_table_name($1)
        )
      );

- function:
    name: create_exception_threshold_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
        'CREATE OR REPLACE FUNCTION trigger_rule.%I(entity integer) RETURNS trigger_rule.%I AS $fn$%s$fn$ LANGUAGE sql VOLATILE',
        trigger.create_exception_threshold_fn_name($1),
        trigger.exception_threshold_table_name($1),
        format(
          'INSERT INTO trigger_rule.%I(entity_id) VALUES ($1) RETURNING *;',
          trigger.exception_threshold_table_name($1)
        )
      );

- function:
    name: get_or_create_exception_threshold_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
        'CREATE OR REPLACE FUNCTION trigger_rule.%I(entity integer) RETURNS trigger_rule.%I AS $fn$%s$fn$ LANGUAGE sql VOLATILE',
        trigger.get_or_create_exception_threshold_fn_name($1),
        trigger.exception_threshold_table_name($1),
        format('SELECT COALESCE(trigger_rule.%I($1), trigger_rule.%I($1));',
           trigger.get_exception_threshold_fn_name($1),
           trigger.create_exception_threshold_fn_name($1)
           )
      );

- function:
    name: create_change_exception_threshold_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
      - data_type: trigger.threshold_def[]
    source: |-
      SELECT format(
        'CREATE OR REPLACE FUNCTION trigger_rule.%I(entity integer, new_start timestamp with time zone, new_expires timestamp with time zone, %s) RETURNS VOID AS $fn$%s$fn$ LANGUAGE sql VOLATILE',
        trigger.change_exception_threshold_fn_name($1),
        string_agg(threshold.name || '_new ' || threshold.data_type, ', '),
        format(
          'SELECT trigger_rule.%I(entity); '
          'UPDATE trigger_rule.%I SET (start, expires, %s) = (new_start, new_expires, %s) WHERE entity_id = entity;',
          trigger.get_or_create_exception_threshold_fn_name($1),
          trigger.exception_threshold_table_name($1),
          string_agg(threshold.name, ', '),
          string_agg(threshold.name || '_new', ', ')
        )
      ) FROM unnest($2) threshold;

- function:
    name: set_thresholds_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_set_thresholds')::name;

- function:
    name: set_thresholds
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: true
    arguments:
    - data_type: trigger.rule
    - name: exprs
      data_type: text
    source: |-
      SELECT trigger.action($1, format(
          'DROP VIEW IF EXISTS  trigger_rule.%I',
          trigger.threshold_view_name($1)
      ));
      SELECT trigger.action($1, format(
          'CREATE VIEW trigger_rule.%I AS '
          'SELECT %s',
          trigger.threshold_view_name($1),
          $2
      ));
      SELECT trigger.action($1, format(
          'ALTER VIEW trigger_rule.%I OWNER TO minerva_admin',
          trigger.threshold_view_name($1)
      ));

      SELECT $1;

- function:
    name: create_set_thresholds_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          $def$CREATE OR REPLACE FUNCTION trigger_rule.%I(%s)
          RETURNS integer AS
          $function$
          BEGIN
              EXECUTE format('CREATE OR REPLACE VIEW trigger_rule.%I AS SELECT %s', %s);
              RETURN 42;
          END;
          $function$ LANGUAGE plpgsql VOLATILE$def$,
          trigger.set_thresholds_fn_name($1),
          array_to_string(array_agg(format('%I %s', t.name, t.data_type)), ', '),
          trigger.threshold_view_name($1),
          array_to_string(array_agg(format('%%L::%s AS %I', t.data_type, t.name)), ', '),
          array_to_string(array_agg(format('$%s', t.row_num)), ', ')
      ) FROM (SELECT d.*, row_number() over() AS row_num FROM trigger.get_threshold_defs($1) d) t;

- function:
    name: create_set_thresholds_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.action($1, trigger.create_set_thresholds_fn_sql($1));

- function:
    name: drop_set_thresholds_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP FUNCTION trigger_rule.%I(%s)',
          trigger.set_thresholds_fn_name($1),
          array_to_string(array_agg(format('%s', t.data_type)), ', ')
      )
      FROM trigger.get_threshold_defs($1) t;

- function:
    name: drop_thresholds_view_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP VIEW trigger_rule.%I', trigger.threshold_view_name($1))

- function:
    name: set_thresholds
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    - name: exprs
      data_type: text
    source: |-
      SELECT trigger.set_thresholds(trigger.get_rule($1), $2);

- function:
    name: create_dummy_thresholds
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - data_type: name[]
    source: |-
      SELECT trigger.set_thresholds(
          $1,
          array_to_string(array_agg(format('NULL::%I %I', kpi.data_type, kpi.name)), ', ')
      ) FROM (
          SELECT (trigger.get_kpi_def($1, kpi_name)).* FROM unnest($2) kpi_name
      ) kpi;

- function:
    name: set_weight
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - name: expression
      data_type: text
    source: |-
      SELECT public.action(
          $1,
          ARRAY[
              trigger.weight_fn_sql($1, $2),
              format(
                  'ALTER FUNCTION trigger_rule.%I(trigger_rule.%I) OWNER TO minerva_admin',
                  trigger.weight_fn_name($1), trigger.details_type_name($1)
              )
          ]
      );

- function:
    name: set_weight
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    - name: expression
      data_type: text
    source: |-
      SELECT trigger.set_weight(trigger.get_rule($1), $2);

- function:
    name: create_dummy_default_weight
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.set_weight($1, 'SELECT 1');

- function:
    name: add_insert_trigger
    schema: trigger
    return_type: notification_directory.notification_store
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      BEGIN
          EXECUTE format(
              $query$
              CREATE OR REPLACE FUNCTION notification.%I()
                  RETURNS trigger AS
              $fnbody$
              BEGIN
                  IF new.weight IS NULL THEN
                      RAISE WARNING 'notification of rule %% entity %% timestamp %% has weight NULL', new.rule_id, new.entity_id, new.timestamp;
                      RETURN NULL;
                  ELSE
                      RETURN new;
                  END IF;
              END;
              $fnbody$ LANGUAGE plpgsql IMMUTABLE;
              $query$,
              notification_directory.staging_table_name($1) || '_insert_checks'
          );

          EXECUTE format(
              $query$
              CREATE TRIGGER check_notifications_trigger
                  BEFORE INSERT
                  ON notification.%I
                  FOR EACH ROW
                  EXECUTE PROCEDURE notification.%I();
              $query$,
              notification_directory.staging_table_name($1),
              notification_directory.staging_table_name($1) || '_insert_checks'
          );

          RETURN $1;
      END;

- function:
    name: create_trigger_notification_store
    schema: trigger
    return_type: notification_directory.notification_store
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    source: |-
      SELECT trigger.add_insert_trigger(
              notification_directory.create_notification_store($1, ARRAY[
                  ('created', 'timestamp with time zone', 'time of notification creation'),
                  ('rule_id', 'integer', 'source rule for this notification'),
                  ('weight', 'integer', 'weight/importance of the notification'),
                  ('details', 'text', 'extra information')
              ]::notification_directory.attr_def[])
      );

- function:
    name: transfer_notifications_from_staging
    schema: trigger
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: notification_directory.notification_store
    source: |-
      DECLARE
          num_rows integer;
      BEGIN
          EXECUTE format(
      $query$
      INSERT INTO notification.%I(entity_id, timestamp, created, rule_id, weight, details, data)
      SELECT staging.entity_id, staging.timestamp, staging.created, staging.rule_id, staging.weight, staging.details, staging.data
      FROM notification.%I staging
      LEFT JOIN notification.%I target ON target.entity_id = staging.entity_id AND target.timestamp = staging.timestamp AND target.rule_id = staging.rule_id
      WHERE target.entity_id IS NULL;
      $query$,
              notification_directory.table_name($1), notification_directory.staging_table_name($1), notification_directory.table_name($1));

          GET DIAGNOSTICS num_rows = ROW_COUNT;

          EXECUTE format('DELETE FROM notification.%I', notification_directory.staging_table_name($1));

          RETURN num_rows;
      END;

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - data_type: notification_directory.notification_store
    - data_type: timestamp with time zone
    source: |-
      DECLARE
          num_rows integer;
      BEGIN
          EXECUTE format(
      $query$
      INSERT INTO notification.%I(entity_id, timestamp, created, rule_id, weight, details, data)
      (SELECT entity_id, timestamp, now(), $1, weight, details, data FROM trigger_rule.%I($2) WHERE data IS NOT NULL)
      $query$,
              notification_directory.staging_table_name($2), trigger.notification_fn_name($1)
          )
          USING $1.id, $3;

          SELECT trigger.transfer_notifications_from_staging($2) INTO num_rows;

          RETURN num_rows;
      END;

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - data_type: timestamp with time zone
    source: |-
      SELECT
          trigger.create_notifications($1, notification_store, $2)
      FROM notification_directory.notification_store
      WHERE id = $1.notification_store_id;

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - data_type: notification_directory.notification_store
    - data_type: interval
    source: |-
      DECLARE
          num_rows integer;
      BEGIN
          EXECUTE format(
      $query$
      INSERT INTO notification.%I(entity_id, timestamp, created, rule_id, weight, details)
      (SELECT entity_id, timestamp, now(), $1, weight, details FROM trigger_rule.%I WHERE timestamp > now() - $2)
      $query$,
              notification_directory.staging_table_name($2), trigger.notification_view_name($1)
          )
          USING $1.id, $3;

          SELECT trigger.transfer_notifications_from_staging($2) INTO num_rows;

          RETURN num_rows;
      END;

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - data_type: interval
    source: |-
      SELECT trigger.create_notifications($1, notification_store, $2)
      FROM notification_directory.notification_store
      WHERE id = $1.notification_store_id;

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.create_notifications($1, notification_store, $1.default_interval)
      FROM notification_directory.notification_store
      WHERE id = $1.notification_store_id;

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: rule_name
      data_type: name
    - name: notification_store_name
      data_type: name
    - data_type: timestamp with time zone
    source: |-
      SELECT trigger.create_notifications(
          trigger.get_rule($1),
          notification_directory.get_notification_store($2),
          $3
      );

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: rule_name
      data_type: name
    - data_type: timestamp with time zone
    source: |-
      SELECT trigger.create_notifications(rule, notification_store, $2)
      FROM trigger.rule
      JOIN notification_directory.notification_store ON notification_store.id = rule.notification_store_id
      WHERE rule.name = $1;

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: rule_name
      data_type: name
    - name: notification_store_name
      data_type: name
    - data_type: interval
    source: |-
      SELECT trigger.create_notifications(
          trigger.get_rule($1),
          notification_directory.get_notification_store($2),
          $3
      );

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: rule_name
      data_type: name
    - data_type: interval
    source: |-
      SELECT trigger.create_notifications(trigger.get_rule($1), $2);

- function:
    name: create_notifications
    schema: trigger
    return_type: integer
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: rule_name
      data_type: name
    source: |-
      SELECT trigger.create_notifications(trigger.get_rule($1));

- function:
    name: with_threshold_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_with_threshold')::name;

- function:
    name: kpi_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_kpi')::name;

- function:
    name: fingerprint_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_fingerprint')::name;

- function:
    name: rule_fn_name 
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT $1.name;

- function:
    name: runnable_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_runnable')::name;

- function:
    name: notification_message_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_notification_message')::name;

- function:
    name: notification_data_fn_name
    schema: trigger
    return_type: name
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT ($1.name || '_notification_data')::name;

#----------------
# Type <rule>_kpi
#----------------

- function:
    name: drop_kpi_type_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP TYPE IF EXISTS trigger_rule.%I CASCADE;',
          trigger.kpi_type_name($1)
      );

#--------------------
# Type <rule>_details
#--------------------

- function:
    name: create_details_type_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - data_type: trigger.rule
      - data_type: trigger.threshold_def[]
    source: |-
      SELECT format(
          'CREATE TYPE trigger_rule.%I AS ('
          '%s'
          ');',
          trigger.details_type_name($1),
          array_to_string(
              array_agg(format('%I %s', (c.col).name, (c.col).data_type)),
              ','
          )
      ) FROM (
          SELECT unnest(
              ARRAY[
                  ('entity_id', 'integer'),
                  ('timestamp', 'timestamp with time zone')
              ]::trigger.threshold_def[]
          ) AS col
          UNION ALL
          SELECT (kpi.name, kpi.data_type)::trigger.threshold_def AS col
          FROM trigger.get_kpi_defs($1) kpi
          UNION ALL
          SELECT unnest($2) AS col
      ) c;

- function:
    name: drop_details_type_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP TYPE IF EXISTS trigger_rule.%I CASCADE;',
          trigger.details_type_name($1)
      );

- function:
    name: create_details_type
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
      - data_type: trigger.threshold_def[]
    source: |-
      SELECT public.action($1, trigger.create_details_type_sql($1, $2));

- function:
    name: drop_details_type
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT public.action($1, trigger.drop_details_type_sql($1));

- function:
    name: create_dummy_thresholds
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
      - data_type: trigger.threshold_def[]
    source: |-
      SELECT trigger.set_thresholds(
          $1,
          array_to_string(array_agg(format('NULL::%s %I', threshold.data_type, threshold.name)), ', ')
      ) FROM unnest($2) threshold;

- function:
    name: create_exception_threshold_table_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - data_type: trigger.rule
      - data_type: trigger.threshold_def[]
    source: |-
      SELECT format(
          'CREATE TABLE trigger_rule.%I(%s);',
          trigger.exception_threshold_table_name($1),
          array_to_string(col_def, ',')
      )
      FROM (
          SELECT
              ARRAY[
                  'id serial',
                  'entity_id integer',
                  'created timestamp with time zone default now()',
                  'start timestamp with time zone',
                  'expires timestamp with time zone',
                  'remark text'
              ]::text[] ||
              array_agg(quote_ident(threshold.name) || ' ' || threshold.data_type) AS col_def
          FROM unnest($2) threshold
      ) c;

- function:
    name: create_exception_threshold_table
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
      - data_type: trigger.threshold_def[]
    source: |-
      SELECT public.action($1, trigger.create_exception_threshold_table_sql($1, $2));
      SELECT public.action($1, trigger.get_exception_threshold_fn_sql($1));
      SELECT public.action($1, trigger.create_exception_threshold_fn_sql($1));
      SELECT public.action($1, trigger.get_or_create_exception_threshold_fn_sql($1));
      SELECT public.action($1, trigger.create_change_exception_threshold_fn_sql($1, $2));
      SELECT public.action($1, format('ALTER TABLE trigger_rule.%I OWNER TO minerva_admin', trigger.exception_threshold_table_name($1)));

#-------------------------------
# Function <rule>_with_threshold
#-------------------------------

- function:
    name: with_threshold_fn_sql_normal
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
      $view$
      SELECT %s
      FROM trigger_rule.%I AS threshold, trigger_rule.%I($1) AS kpi
      LEFT JOIN trigger_rule.%I exc ON
          exc.entity_id = kpi.entity_id AND
          exc.start <= timestamp AND
          exc.expires > timestamp
      $view$,
          array_to_string(col_def, ','),
          trigger.threshold_view_name($1),
          trigger.kpi_fn_name($1),
          trigger.exception_threshold_table_name($1)
      )
      FROM (
          SELECT
              ARRAY['kpi.*']::text[] || array_agg(format('COALESCE(exc.%I, threshold.%I) AS %I', threshold.name, threshold.name, threshold.name)) AS col_def
          FROM trigger.get_threshold_defs($1) threshold
      ) c;

- function:
    name: with_threshold_fn_sql_no_thresholds
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
          'SELECT * FROM trigger_rule.%I($1)',
          trigger.kpi_fn_name($1)
      );

- function:
    name: has_thresholds
    schema: trigger
    return_type: boolean
    language: sql
    description: "Return true if there is a view with thresholds for the specified rule"
    volatility: stable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT EXISTS(
          SELECT 1
          FROM pg_class
          WHERE relname = trigger.threshold_view_name($1) AND relkind = 'v'
      );

- function:
    name: with_threshold_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - data_type: trigger.rule
    source: |-
      --SELECT CASE WHEN trigger.has_thresholds($1) THEN
      SELECT CASE WHEN true THEN
          trigger.with_threshold_fn_sql_normal($1)
      ELSE
          trigger.with_threshold_fn_sql_no_thresholds($1)
      END;

- function:
    name: create_with_threshold_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT public.action(
          $1,
          ARRAY[
              format(
                  'CREATE OR REPLACE FUNCTION trigger_rule.%I(timestamp with time zone) RETURNS SETOF trigger_rule.%I AS $fn$%s$fn$ LANGUAGE sql STABLE',
                  trigger.with_threshold_fn_name($1),
                  trigger.details_type_name($1),
                  trigger.with_threshold_fn_sql($1)
              ),
              format(
                  'ALTER FUNCTION trigger_rule.%I(timestamp with time zone) OWNER TO minerva_admin',
                  trigger.with_threshold_fn_name($1)
              )
          ]
      );

- function:
    name: drop_with_threshold_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP FUNCTION trigger_rule.%I(timestamp with time zone)',
          trigger.with_threshold_fn_name($1)
      );

#-----------------------------------

- function:
    name: define_thresholds
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
      - data_type: trigger.rule
      - data_type: trigger.threshold_def[]
    source: |-
      SELECT trigger.create_details_type($1, $2);
      SELECT CASE WHEN array_length($2, 1) > 0 THEN
          trigger.create_dummy_thresholds($1, $2)
      END;
      SELECT trigger.create_exception_threshold_table($1, $2);
      SELECT CASE WHEN array_length($2, 1) > 0 THEN
          trigger.create_set_thresholds_fn($1)
      END;
      SELECT trigger.create_with_threshold_fn($1);

#-------------------------------------
# Function <rule>_notification_message
#-------------------------------------

- function:
    name: notification_message_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    - name: expression
      data_type: text
    source: |-
      SELECT format(
      'CREATE OR REPLACE FUNCTION trigger_rule.%I(trigger_rule.%I)
          RETURNS text
      AS $function$
      SELECT (%s)::text
      $function$ LANGUAGE SQL IMMUTABLE',
          trigger.notification_message_fn_name($1),
          trigger.details_type_name($1),
          $2
      );

- function:
    name: drop_notification_message_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP FUNCTION trigger_rule.%I',
          trigger.notification_message_fn_name($1),
          trigger.details_type_name($1)
      );

- function:
    name: create_notification_message_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    - name: expression
      data_type: text
    source: |-
      SELECT public.action(
          $1,
          ARRAY[
              trigger.notification_message_fn_sql($1, $2),
              format(
                  'ALTER FUNCTION trigger_rule.%I(trigger_rule.%I) OWNER TO minerva_admin',
                  trigger.notification_message_fn_name($1),
                  trigger.details_type_name($1)
              )
          ]
      );

- function:
    name: create_dummy_notification_message_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.create_notification_message_fn($1, quote_literal($1.name));

- function:
    name: define_notification_message
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    - name: expression
      data_type: text
    source: |-
      SELECT trigger.create_notification_message_fn(trigger.get_rule($1), $2);

#----------------------------------
# Function <rule>_notification_data
#----------------------------------

- function:
    name: create_notification_data_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    - name: expression
      data_type: text
    source: |-
      SELECT format(
      'CREATE OR REPLACE FUNCTION trigger_rule.%I(trigger_rule.%I)
          RETURNS json
      AS $function$
      DECLARE
        data json;
      BEGIN
      SELECT (%s) INTO data;
      RETURN data;
      END;
      $function$ LANGUAGE PLPGSQL STABLE',
          trigger.notification_data_fn_name($1),
          trigger.details_type_name($1),
          $2
      );

- function:
    name: drop_notification_data_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP FUNCTION trigger_rule.%I',
          trigger.notification_data_fn_name($1),
          trigger.details_type_name($1)
      );

- function:
    name: create_notification_data_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    - name: expression
      data_type: text
    source: |-
      SELECT public.action(
          $1,
          ARRAY[
              trigger.create_notification_data_fn_sql($1, $2),
              format(
                  'ALTER FUNCTION trigger_rule.%I(trigger_rule.%I) OWNER TO minerva_admin',
                  trigger.notification_data_fn_name($1),
                  trigger.details_type_name($1)
              ),
              format(
                  'GRANT EXECUTE ON FUNCTION trigger_rule.%I(trigger_rule.%I) TO minerva',
                  trigger.notification_data_fn_name($1),
                  trigger.details_type_name($1)
              )
          ]
      );

- function:
    name: create_dummy_notification_data_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.create_notification_data_fn($1, format('''"{}"''::json', $1.name));

- function:
    name: define_notification_data
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: name
    - name: expression
      data_type: text
    source: |-
      SELECT trigger.create_notification_data_fn(trigger.get_rule($1), $2);

#------------------------------------------
# Function <rule>(timestamp with time zone)
#------------------------------------------

- function:
    name: rule_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    arguments:
    - data_type: trigger.rule
    - name: where_clause
      data_type: text
    source: |-
      SELECT format(
          'SELECT * FROM trigger_rule.%I($1) WHERE %s;',
          trigger.with_threshold_fn_name($1), $2
      );

- function:
    name: create_rule_fn_sql
    schema: trigger
    return_type: text[]
    language: sql
    volatility: immutable
    arguments:
    - data_type: trigger.rule
    - name: rule_view_sql
      data_type: text
    source: |-
      SELECT ARRAY[
          format(
              'CREATE OR REPLACE FUNCTION trigger_rule.%I(timestamp with time zone) RETURNS SETOF trigger_rule.%I AS $fn$ %s $fn$ LANGUAGE sql STABLE',
              trigger.rule_fn_name($1),
              trigger.details_type_name($1),
              $2
          ),
          format(
              'ALTER FUNCTION trigger_rule.%I(timestamp with time zone) OWNER TO minerva_admin',
              trigger.rule_fn_name($1)
          )
      ];

- function:
    name: create_rule_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    - name: rule_view_sql
      data_type: text
    source: |-
      SELECT public.action($1, trigger.create_rule_fn_sql($1, $2));

- function:
    name: drop_rule_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'DROP FUNCTION trigger_rule.%I(timestamp with time zone)',
          trigger.rule_fn_name($1)
      );

- function:
    name: set_condition
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    - name: sql
      data_type: text
    source: |-
      SELECT trigger.create_rule_fn($1, trigger.rule_fn_sql($1, $2));


#------------------------------------
# Function <rule>_create_notification
#------------------------------------

- function:
    name: notification_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format(
          'CREATE OR REPLACE FUNCTION trigger_rule.%I(timestamp with time zone)
          RETURNS SETOF trigger.notification
      AS $fn$
      SELECT
          n.entity_id,
          n.timestamp,
          COALESCE(exc.weight, trigger_rule.%I(n)) AS weight,
          trigger_rule.%I(n) AS details,
          trigger_rule.%I(n) AS data
      FROM trigger_rule.%I($1) AS n
      LEFT JOIN trigger_rule.%I AS exc ON
          exc.entity_id = n.entity_id AND
          exc.start <= n.timestamp AND
          exc.expires > n.timestamp $fn$ LANGUAGE sql STABLE',
          trigger.notification_fn_name($1),
          trigger.weight_fn_name($1),
          trigger.notification_message_fn_name($1),
          trigger.notification_data_fn_name($1),
          $1.name,
          trigger.exception_weight_table_name($1)
      );

- function:
    name: create_notification_fn_sql
    schema: trigger
    return_type: text[]
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT ARRAY[
          trigger.notification_fn_sql($1),
          format('ALTER FUNCTION trigger_rule.%I(timestamp with time zone) OWNER TO minerva_admin', trigger.notification_fn_name($1))
      ];

- function:
    name: create_notification_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT public.action($1, trigger.create_notification_fn_sql($1));

- function:
    name: get_notification_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT pg_get_functiondef(oid)
      FROM pg_proc
      WHERE proname = trigger.notification_fn_name($1);

- function:
    name: drop_notification_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP FUNCTION trigger_rule.%I(timestamp with time zone)', trigger.notification_fn_name($1));

#----------------------------
# Function <rule>_fingerprint
#----------------------------

- function:
    name: create_fingerprint_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    - name: fn_sql
      data_type: text
    source: |-
      SELECT format(
          $fn$CREATE OR REPLACE FUNCTION trigger_rule.%I(timestamp with time zone)
            RETURNS text
          AS $function$
            %s
          $function$ LANGUAGE sql STABLE$fn$,
          trigger.fingerprint_fn_name($1),
          $2
      );

- function:
    name: create_fingerprint_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.create_fingerprint_fn_sql(
          $1,
          $fn_body$SELECT now()::text;$fn_body$
      );

- function:
    name: create_fingerprint_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT public.action($1, trigger.create_fingerprint_fn_sql($1));

- function:
    name: drop_fingerprint_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: immutable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP FUNCTION IF EXISTS trigger_rule.%I(timestamp with time zone)', trigger.fingerprint_fn_name($1));

- function:
    name: drop_fingerprint_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT public.action($1, trigger.drop_fingerprint_fn_sql($1));

#-------------------------
# Function <rule>_runnable
#-------------------------

- function:
    name: create_runnable_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    - name: fn_body
      data_type: text
    source: |-
      SELECT format(
          $fn$CREATE OR REPLACE FUNCTION trigger_rule.%I(timestamp with time zone)
            RETURNS boolean
          AS $function$
          %s
          $function$ LANGUAGE sql STABLE$fn$,
          trigger.runnable_fn_name($1),
          $2
      );

- function:
    name: create_runnable_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT trigger.create_runnable_fn_sql($1, 'SELECT TRUE;');

- function:
    name: create_runnable_fn
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT public.action($1, trigger.create_runnable_fn_sql($1));

- function:
    name: drop_runnable_fn_sql
    schema: trigger
    return_type: text
    language: sql
    volatility: stable
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT format('DROP FUNCTION trigger_rule.%I(timestamp with time zone)', trigger.runnable_fn_name($1));

- function:
    name: set_runnable
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    arguments:
    - data_type: trigger.rule
    - name: fn_sql
      data_type: text
    source: |-
      SELECT public.action($1, trigger.create_runnable_fn_sql($1, $2));

#-----------
# Setup rule
#-----------

- function:
    name: setup_rule
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    - data_type: trigger.threshold_def[]
    source: |-
      SELECT trigger.define_thresholds($1, $2);
      SELECT trigger.create_exception_weight_table($1);
      SELECT trigger.create_dummy_default_weight($1);
      SELECT trigger.create_dummy_notification_message_fn($1);
      SELECT trigger.create_dummy_notification_data_fn($1);
      SELECT trigger.set_condition($1, 'true');
      SELECT trigger.create_notification_fn($1);
      SELECT trigger.create_fingerprint_fn($1);
      SELECT trigger.create_runnable_fn($1);

- function:
    name: create_rule
    schema: trigger
    return_type: trigger.rule
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: text
    - data_type: trigger.threshold_def[]
    source: |-
      SELECT trigger.setup_rule(trigger.define($1::name), $2);

- function:
    name: cleanup_rule
    schema: trigger
    return_type: trigger.rule
    language: plpgsql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      BEGIN
          EXECUTE trigger.drop_set_thresholds_fn_sql($1);
          EXECUTE trigger.drop_rule_fn_sql($1);
          EXECUTE trigger.drop_kpi_function_sql($1);
          EXECUTE trigger.drop_notification_fn_sql($1);
          EXECUTE trigger.drop_runnable_fn_sql($1);
          EXECUTE trigger.drop_fingerprint_fn_sql($1);
          EXECUTE trigger.drop_with_threshold_fn_sql($1);
          EXECUTE trigger.drop_weight_fn_sql($1);
          EXECUTE trigger.drop_notification_message_fn_sql($1);
          EXECUTE trigger.drop_exception_weight_table_sql($1);
          EXECUTE trigger.drop_thresholds_view_sql($1);
          EXECUTE trigger.drop_exception_threshold_table_sql($1);
          EXECUTE trigger.drop_notification_type_sql($1);
          EXECUTE trigger.drop_details_type_sql($1);
          EXECUTE trigger.drop_kpi_type_sql($1);

          RETURN $1;
      END;

- function:
    name: delete_rule
    schema: trigger
    return_type: bigint
    language: sql
    volatility: volatile
    arguments:
    - data_type: name
    source: 
        SELECT trigger.cleanup_rule(rule) FROM trigger.rule WHERE name = $1;

        WITH deleted AS (
            DELETE FROM trigger.rule WHERE name = $1 RETURNING *
        )
        SELECT count(*) FROM deleted;


- function:
    name: tag
    schema: trigger
    return_type: trigger.rule_tag_link
    language: sql
    volatility: volatile
    strict: false
    secdef: false
    arguments:
    - name: tag_name
      data_type: varchar
    - name: rule_id
      data_type: integer
    description: |-
      Add tag with name tag_name to rule with id rule_id.
      
      The tag must already exist.
    source: |-
      INSERT INTO trigger.rule_tag_link (rule_id, tag_id)
      SELECT $2, tag.id FROM directory.tag WHERE name = $1
      RETURNING *;

- function:
    name: truncate
    schema: trigger
    return_type: timestamp with time zone
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: timestamp with time zone
    - data_type: interval
    source: |-
      SELECT CASE
          WHEN $2 = '1 day' THEN
              date_trunc('day', $1)
          WHEN $2 = '1 week' THEN
              date_trunc('week', $1)
          ELSE
              to_timestamp((
                  extract(epoch FROM $1)::integer / extract(epoch FROM $2)::integer
              )::integer * extract(epoch FROM $2))
          END;

- function:
    name: timestamps
    schema: trigger
    return_type: timestamp with time zone
    returns_set: true
    language: sql
    volatility: stable
    strict: false
    secdef: false
    arguments:
    - data_type: trigger.rule
    source: |-
      SELECT generate_series(
          trigger.truncate(now(), $1.granularity),
          trigger.truncate(now(), $1.granularity) - $1.default_interval,
          - $1.granularity
      );

###################
###################
###             ###
### entity sets ###
###             ###
###################
###################

- query:
    query: directory.create_entity_type('entity_set')

- query:
    query: directory.create_data_source('minerva')

- query:
    query: |-
      CALL attribute_directory.create_attribute_store(
        'minerva',
        'entity_set',
        ARRAY[
          ('name', 'text', ''),
          ('fullname', 'text', ''),
          ('group', 'text', ''),
          ('source_entity_type', 'text', ''),
          ('owner', 'text', ''),
          ('description', 'text', ''),
          ('last_update', 'text', '')
        ]::attribute_directory.attribute_descr[]
      )
    select: false

- function:
    name: entity_set_exists
    schema: relation_directory
    return_type: boolean
    language: plpgsql
    volatility: stable
    arguments:
    - data_type: text
      name: owner
    - data_type: text
      name: name
    source: |-
      DECLARE
        row_count integer;
      BEGIN
        SELECT action_count(format(
          'SELECT * FROM attribute.minerva_entity_set '
          'WHERE owner = ''%s'' AND name = ''%s'';',
          $1,
          $2
        )) INTO row_count;
        RETURN CASE row_count
          WHEN 0 THEN false
          ELSE true
        END;
      END;

- function:
    name: create_entity_set
    schema: relation_directory
    return_type: attribute.minerva_entity_set
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: text
      name: name
    - data_type: text
      name: group
    - data_type: text
      name: entity_type_name
    - data_type: text
      name: owner
    - data_type: text
      name: description
    source: |-
      DECLARE
        entity_id integer;
      BEGIN
        EXECUTE FORMAT(
          'CREATE TABLE IF NOT EXISTS relation."%s->entity_set"('
          'source_id integer, '
          'target_id integer, '
          'PRIMARY KEY (source_id, target_id));',
          entity_type_name
        );
        PERFORM relation_directory.name_to_type(entity_type_name || '->entity_set');
        SELECT id FROM entity.to_entity_set(name || '_' || "group" || '_' || owner) INTO entity_id;
        INSERT INTO attribute_staging.minerva_entity_set(
            entity_id, timestamp, name, fullname, "group", source_entity_type, owner, description, last_update
          ) VALUES (
            entity_id,
            now(),
            name,
            name || '_' || "group" || '_' || owner,
            "group",
            entity_type_name,
            owner,
            description,
            CURRENT_DATE::text
          );
        PERFORM attribute_directory.transfer_staged(attribute_directory.get_attribute_store('minerva', 'entity_set'));
        PERFORM attribute_directory.materialize_curr_ptr(attribute_directory.get_attribute_store('minerva', 'entity_set'));
        RETURN es FROM attribute.minerva_entity_set es WHERE es.name = $1 AND es.owner = $4;
      END;

- function:
    name: update_entity_set_attributes
    schema: relation_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: minerva_entity_set_id
    source: |-
      BEGIN
        INSERT INTO attribute_staging.minerva_entity_set(
          entity_id, timestamp, name, fullname, "group", source_entity_type, owner, description, last_update
        ) SELECT
          t.entity_id,
          now(),
          t.name,
          t.fullname,
          t."group",
          t.source_entity_type,
          t.owner,
          t.description,
          CURRENT_DATE::text
        FROM attribute.minerva_entity_set t
        WHERE t.id = $1;
      END;

- function:
    name: get_entity_set_data
    schema: relation_directory
    return_type: attribute.minerva_entity_set
    language: sql
    volatility: stable
    arguments:
    - data_type: text
      name: name
    - data_type: text
      name: owner
    source: SELECT * FROM attribute.minerva_entity_set WHERE name = $1 AND owner = $2;

- function:
    name: add_entity_to_set
    schema: relation_directory
    return_type: attribute.minerva_entity_set
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: minerva_entity_set_id
    - data_type: text
      name: entity
    source: |-
      DECLARE
        set attribute.minerva_entity_set;
      BEGIN
        SELECT * FROM attribute.minerva_entity_set WHERE id = $1 INTO set;
        PERFORM relation_directory.update_entity_set_attributes($1);
        PERFORM action(FORMAT(
          'INSERT INTO relation."%s->entity_set" (source_id, target_id) '
          'SELECT source.id AS source_id, %s AS target '
          'FROM entity.%I source '
          'WHERE source.name = ''%s'''
          'ON CONFLICT DO NOTHING;',
          set.source_entity_type,
          set.entity_id,
          set.source_entity_type,
          $2
        ));
        RETURN set;
      END;

- function:
    name: remove_entity_from_set
    schema: relation_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: minerva_entity_set_id
    - data_type: text
      name: entity
    source: |-
      DECLARE
        set attribute.minerva_entity_set;
      BEGIN
        SELECT * FROM attribute.minerva_entity_set WHERE id = $1 INTO set;
        PERFORM relation_directory.update_entity_set_attributes($1);
        PERFORM action(FORMAT(
          'DELETE es FROM relation."%s->entity_set" es '
          'JOIN entity.%I source ON es.source_id = source.id '
          'WHERE source.name = ''%s'' AND target_id = %s;',
          set.source_entity_type,
          set.source_entity_type,
          $2,
          set.entity_id
        ));
      END;

- function:
    name: add_entities_to_set
    schema: relation_directory
    return_type: void
    language: sql
    volatility: volatile
    arguments:
    - data_type: integer
      name: minerva_entity_set_id
    - data_type: text[]
      name: entities
    source: |-
      SELECT relation_directory.add_entity_to_set($1, e) FROM unnest($2) e;

- function:
    name: change_set_entities
    schema: relation_directory
    return_type: void
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: minerva_entity_set_id
    - data_type: text[]
      name: entities
    description: Set the entities in the set to exactly the specified entities
    source: |-
      DECLARE
        set attribute.minerva_entity_set;
      BEGIN
        SELECT * FROM attribute.minerva_entity_set WHERE id = $1 INTO set;
        PERFORM action(FORMAT(
          'DELETE FROM relation."%s->entity_set" '
          'WHERE target_id = %s;',
          set.source_entity_type,
          set.entity_id
        ));
        PERFORM relation_directory.add_entities_to_set($1, $2);
      END;

- function:
    name: change_set_entities_guarded
    schema: relation_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: integer
      name: minerva_entity_set_id
    - data_type: text[]
      name: entities
    description: |-
      Only sets the entities if all specified entities are actually valid.
      Returns those entities that were invalid.
    source: |-
      DECLARE
        set attribute.minerva_entity_set;
        entity text;
        real_entity text;
        result text[];
        newresult text[];
      BEGIN
        SELECT * FROM attribute.minerva_entity_set WHERE id = $1 INTO set;
        SELECT $2 INTO result;
        FOREACH entity IN ARRAY $2 LOOP
          EXECUTE FORMAT(
            'SELECT name FROM entity.%I WHERE name = ''%s'';',
            set.source_entity_type,
            entity
          ) INTO real_entity;
          SELECT array_remove(result, real_entity) INTO result;
        END LOOP;
        IF ARRAY_LENGTH(result, 1) IS NULL THEN
          PERFORM relation_directory.change_set_entities($1, $2);
        END IF;
        RETURN result;
      END;

- function:
    name: get_entity_set_members
    schema: relation_directory
    return_type: text[]
    language: plpgsql
    volatility: stable
    arguments:
    - data_type: integer
      name: minerva_entity_set_id
    source: |-
      DECLARE
        set attribute.minerva_entity_set;
        result text[];
      BEGIN
        SELECT * FROM attribute.minerva_entity_set WHERE id = $1 INTO set;
        EXECUTE FORMAT(
          'SELECT array_agg(e.name) '
          'FROM relation."%s->entity_set" es JOIN entity.%I e ON es.source_id = e.id '
          'WHERE es.target_id = %s',
          set.source_entity_type,
          set.source_entity_type,
          set.entity_id
        ) INTO result;
        RETURN result;
      END;

- function:
    name: create_entity_set_guarded
    schema: relation_directory
    return_type: text[]
    language: plpgsql
    volatility: volatile
    arguments:
    - data_type: text
      name: name
    - data_type: text
      name: group
    - data_type: text
      name: entity_type_name
    - data_type: text
      name: owner
    - data_type: text
      name: description
    - data_type: text[]
      name: entities
    source: |-
      DECLARE
        entity text;
        real_entity text;
        result text[];
        newresult text[];
        entityset integer;
      BEGIN
        SELECT $6 INTO result;
        FOREACH entity IN ARRAY $6 LOOP
          EXECUTE FORMAT(
            'SELECT name FROM entity.%I WHERE name = ''%s'';',
            $3,
            entity
          ) INTO real_entity;
          SELECT array_remove(result, real_entity) INTO result;
        END LOOP;
        IF ARRAY_LENGTH(result, 1) IS NULL THEN
          SELECT id FROM relation_directory.create_entity_set($1, $2, $3, $4, $5) INTO entityset;
          PERFORM relation_directory.change_set_entities(entityset, $6);
        END IF;
        RETURN result;
      END;

- function:
    name: get_entity_set_members
    schema: relation_directory
    return_type: text[]
    language: sql
    volatility: stable
    arguments:
    - name: name
      data_type: text
    - name: owner
      data_type: text
    source: |-
      SELECT relation_directory.get_entity_set_members(es.id)
        FROM attribute.minerva_entity_set es
        WHERE owner = $2 AND name = $1;

###################
###################

- composite_type:
    name: trend_data
    schema: trend
    columns:
    - name: timestamp
      data_type: timestamptz
      nullable: false
    - name: entity_id
      data_type: integer
      nullable: false
    - name: counters
      data_type: numeric[]
      nullable: false

- function:
    name: get_table_name_for_trend
    schema: trend_directory
    return_type: name
    language: sql
    volatility: stable
    arguments:
      - name: trend
        data_type: text
      - name: entity
        data_type: text
      - name: granularity
        data_type: interval
    source: |-
      SELECT tsp.name FROM trend_directory.table_trend t
        JOIN trend_directory.trend_store_part tsp ON tsp.id = t.trend_store_part_id
        JOIN trend_directory.trend_store ts ON ts.id = tsp.trend_store_id
        JOIN directory.entity_type et ON et.id = ts.entity_type_id
        WHERE t.name = $1
          AND ts.granularity = $3
          AND et.name = $2;

- function:
    name: create_dynamic_source_description
    schema: trend
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - name: trend
        data_type: text
      - name: counter
        data_type: integer
      - name: entity
        data_type: text
      - name: granularity
        data_type: interval
    source:
      SELECT FORMAT(
        'trend.%I t%s %s ',
        trend_directory.get_table_name_for_trend($1, $3, $4),
        $2,
        CASE $2
          WHEN 1 THEN ''
          ELSE FORMAT('ON t%s.entity_id = t1.entity_id AND t%s.timestamp = t1.timestamp',
                      $2, $2)
        END
        );

- function:
    name: get_dynamic_trend_data_sql
    schema: trend
    return_type: text
    language: sql
    volatility: stable
    arguments:
      - name: timestamp
        data_type: timestamptz
      - name: entity_type_name
        data_type: text
      - name: granularity
        data_type: interval
      - name: counter_names
        data_type: text[]
    source: |-
      WITH ref as (
        SELECT
          FORMAT('t%s.%I::numeric', i, c) as column_description,
          trend.create_dynamic_source_description(c, i::integer, $2, $3) as join_data             
        FROM unnest($4) WITH ORDINALITY as counters(c,i)
      )
      SELECT FORMAT(
          'SELECT ''%s''::timestamp, t1.entity_id, ARRAY[%s] '
          'FROM %s'
          'JOIN entity.%I ent ON ent.id = t1.entity_id '
          'WHERE t1.timestamp = ''%s'';',
        $1,
        string_agg(column_description, ', '),
        string_agg(join_data, ' JOIN '),
        $2,
        $1
        ) FROM ref;

- function:
    name: get_dynamic_trend_data
    schema: trend
    return_type: setof trend.trend_data
    language: plpgsql
    volatility: stable
    arguments:
      - name: timestamp
        data_type: timestamp with time zone
      - name: entity_type_name
        data_type: text
      - name: granularity
        data_type: interval
      - name: counter_names
        data_type: text[]
    source:
      DECLARE
        r trend.trend_data%rowtype;
      BEGIN
        IF $4 = ARRAY[]::text[]
        THEN
          FOR r IN EXECUTE FORMAT('SELECT ''%s''::timestamptz, e.id, ARRAY[]::numeric[] from entity.%I e', $1, $2)
            LOOP
              RETURN NEXT r;
            END LOOP;
       ELSE
          FOR r IN EXECUTE trend.get_dynamic_trend_data_sql($1, $2, $3, $4)
            LOOP
              RETURN NEXT r;
            END LOOP;
        END IF;
        RETURN;
      END;

- function:
    name: mapping_id
    schema: trend
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    arguments:
      - data_type: timestamp with time zone
    source: |-
      SELECT $1;

- function:
    name: mapping_15m->1d
    schema: trend
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    arguments:
      - data_type: timestamp with time zone
    source: |-
      SELECT date_trunc('day', $1 - interval '15m') + interval '1d';

- function:
    name: mapping_15m->1h
    schema: trend
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    arguments:
      - data_type: timestamp with time zone
    source: |-
      SELECT date_trunc('hour', $1 - interval '15m') + interval '1h';

- function:
    name: mapping_30m->1d
    schema: trend
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    arguments:
      - data_type: timestamp with time zone
    source: |-
      SELECT date_trunc('day', $1 - interval '30m') + interval '1d';

- function:
    name: mapping_30m->1h
    schema: trend
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    arguments:
      - data_type: timestamp with time zone
    source: |-
      SELECT date_trunc('hour', $1 - interval '30m') + interval '1h';

- function:
    name: mapping_1d->1w
    schema: trend
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    arguments:
      - data_type: timestamp with time zone
    source: |-
      SELECT date_trunc('week', $1 - interval '1d') + interval '1w';

- function:
    name: mapping_1d->1month
    schema: trend
    return_type: timestamp with time zone
    language: sql
    volatility: immutable
    arguments:
      - data_type: timestamp with time zone
    source: |-
      SELECT date_trunc('month', $1 - interval '1d') + interval '1month';
